const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// Import the SecurityController to test exploit detection
const SecurityController = require('./server/controllers/SecurityController');

// Mock request and response objects
const mockReq = { body: {}, params: {}, query: {} };
const mockRes = {
    json: (data) => console.log('Response:', JSON.stringify(data, null, 2)),
    status: (code) => ({ json: (data) => console.log(`Status ${code}:`, JSON.stringify(data, null, 2)) })
};

async function analyzeExploitDetection() {
    console.log('üîç EXPLOIT DETECTION ANALYSIS');
    console.log('='.repeat(60));

    // Get uploaded files
    const uploadedFiles = SecurityController.getUploadedFiles();
    console.log(`\nüìÅ Found ${uploadedFiles.length} uploaded files:`);
    uploadedFiles.forEach((file, index) => {
        console.log(`   ${index + 1}. ${file.originalName} (${file.size} bytes)`);
    });

    if (uploadedFiles.length === 0) {
        console.log('‚ùå No files available for analysis');
        return;
    }

    // Test each exploit type individually
    const exploitTypes = [
        'sqlInjection',
        'xss',
        'csrf',
        'authBypass',
        'directoryTraversal',
        'commandInjection',
        'networkScanner',
        'sslAnalyzer',
        'webVulnScanner',
        'bufferOverflow'
    ];

    console.log('\nüß™ TESTING INDIVIDUAL EXPLOITS');
    console.log('-'.repeat(40));

    for (const exploitType of exploitTypes) {
        console.log(`\nüî¨ Testing ${exploitType}...`);

        try {
            // Run the exploit on uploaded files
            const result = await SecurityController.scanUploadedFiles(exploitType, uploadedFiles, {
                scanId: `debug_${exploitType}_${Date.now()}`
            });

            console.log(`   ‚úÖ ${exploitType}: ${result.vulnerabilities.length} vulnerabilities found`);

            if (result.vulnerabilities.length > 0) {
                result.vulnerabilities.forEach((vuln, index) => {
                    console.log(`      ${index + 1}. ${vuln.type} (${vuln.severity})`);
                    if (vuln.location) console.log(`         Location: ${vuln.location}`);
                    if (vuln.evidence) console.log(`         Evidence: ${vuln.evidence.substring(0, 100)}...`);
                });
            }

        } catch (error) {
            console.log(`   ‚ùå ${exploitType}: Failed - ${error.message}`);
        }
    }

    // Analyze file contents for patterns
    console.log('\nüìÑ FILE CONTENT ANALYSIS');
    console.log('-'.repeat(30));

    for (const file of uploadedFiles) {
        console.log(`\nüìã Analyzing ${file.originalName}:`);

        try {
            const content = fs.readFileSync(file.path, 'utf8');
            console.log(`   Size: ${content.length} characters`);
            console.log(`   Lines: ${content.split('\n').length}`);

            // Check for common vulnerability patterns
            const patterns = {
                'SQL Patterns': [
                    /SELECT\s+.*\s+FROM/gi,
                    /INSERT\s+INTO/gi,
                    /UPDATE\s+.*\s+SET/gi,
                    /DELETE\s+FROM/gi,
                    /\$_[GET|POST|REQUEST]/gi,
                    /query.*\+.*\$/gi
                ],
                'XSS Patterns': [
                    /<script/gi,
                    /javascript:/gi,
                    /onclick=/gi,
                    /onerror=/gi,
                    /onload=/gi,
                    /innerHTML/gi,
                    /document\.write/gi
                ],
                'Command Injection': [
                    /exec\(/gi,
                    /system\(/gi,
                    /shell_exec/gi,
                    /passthru/gi,
                    /subprocess/gi,
                    /os\.system/gi
                ],
                'Buffer Overflow': [
                    /strcpy\(/gi,
                    /strcat\(/gi,
                    /sprintf\(/gi,
                    /gets\(/gi,
                    /Buffer\.alloc/gi,
                    /Buffer\.from/gi,
                    /malloc\(/gi
                ],
                'Directory Traversal': [
                    /\.\.\//gi,
                    /\.\.\\/gi,
                    /path\.join/gi,
                    /fs\.readFile/gi,
                    /require\(/gi
                ],
                'CSRF Patterns': [
                    /<form/gi,
                    /method\s*=\s*['"](post|put|delete)['"]/gi,
                    /csrf/gi,
                    /token/gi
                ]
            };

            Object.entries(patterns).forEach(([category, regexList]) => {
                const matches = regexList.reduce((count, regex) => {
                    const found = content.match(regex);
                    return count + (found ? found.length : 0);
                }, 0);

                if (matches > 0) {
                    console.log(`   üéØ ${category}: ${matches} matches`);
                }
            });

            // Show first 200 characters for context
            console.log(`   üìù Content preview: ${content.substring(0, 200)}...`);

        } catch (error) {
            console.log(`   ‚ùå Failed to read file: ${error.message}`);
        }
    }

    // Test why only buffer overflow might be showing
    console.log('\nüîç BUFFER OVERFLOW SPECIFIC ANALYSIS');
    console.log('-'.repeat(40));

    try {
        const bufferOverflowExploit = SecurityController.exploits.bufferOverflow;

        for (const file of uploadedFiles) {
            const content = fs.readFileSync(file.path, 'utf8');
            console.log(`\nüî¨ Buffer overflow analysis for ${file.originalName}:`);

            // Check specific buffer overflow patterns
            const bufferPatterns = [
                { name: 'Buffer.alloc', regex: /Buffer\.alloc/gi },
                { name: 'Buffer.from', regex: /Buffer\.from/gi },
                { name: 'malloc calls', regex: /malloc\s*\(/gi },
                { name: 'strcpy calls', regex: /strcpy\s*\(/gi },
                { name: 'Large arrays', regex: /\[\s*\d{3,}\s*\]/gi },
                { name: 'Repeat patterns', regex: /repeat\s*\(\s*\d+\s*\)/gi },
                { name: 'Multiplication', regex: /\*\s*\d{3,}/gi }
            ];

            bufferPatterns.forEach(pattern => {
                const matches = content.match(pattern.regex);
                if (matches && matches.length > 0) {
                    console.log(`   üéØ ${pattern.name}: ${matches.length} matches`);
                    matches.slice(0, 3).forEach(match => {
                        console.log(`      - "${match}"`);
                    });
                }
            });
        }
    } catch (error) {
        console.log(`‚ùå Buffer overflow analysis failed: ${error.message}`);
    }

    // Summary and recommendations
    console.log('\nüìä ANALYSIS SUMMARY');
    console.log('-'.repeat(25));
    console.log('This analysis helps understand:');
    console.log('1. Which exploits are actually finding vulnerabilities');
    console.log('2. What patterns exist in your uploaded files');
    console.log('3. Why some exploits may not detect anything');
    console.log('4. Whether the issue is with detection logic or file content');

    console.log('\nüí° If only buffer overflow shows results:');
    console.log('   - Your files may primarily contain buffer-related patterns');
    console.log('   - Other exploits may target web-specific vulnerabilities');
    console.log('   - File-based scanning differs from URL-based scanning');
    console.log('   - Consider uploading web app files (PHP, HTML, etc.) for broader detection');
}

// Run the analysis
if (require.main === module) {
    console.log('Starting exploit detection analysis...\n');
    analyzeExploitDetection()
        .then(() => {
            console.log('\n‚úÖ Analysis completed!');
            process.exit(0);
        })
        .catch(error => {
            console.error('\n‚ùå Analysis failed:', error);
            process.exit(1);
        });
}

module.exports = { analyzeExploitDetection };
