const axios = require('axios');
const { spawn } = require('child_process');
const crypto = require('crypto');

class BufferOverflowExploit {
    constructor() {
        this.displayName = 'Buffer Overflow Scanner';
        this.description = 'Buffer overflow vulnerability detection and exploitation';
        this.severity = 'critical';
        this.category = 'memory-corruption';
        this.version = '2.0.0';

        // Buffer overflow patterns and payloads
        this.overflowPatterns = {
            // Simple buffer overflow patterns
            basic: [
                'A' * 100,
                'A' * 256,
                'A' * 512,
                'A' * 1024,
                'A' * 2048,
                'A' * 4096,
                'A' * 8192
            ],

            // Format string vulnerabilities
            formatString: [
                '%x%x%x%x%x%x%x%x',
                '%p%p%p%p%p%p%p%p',
                '%s%s%s%s%s%s%s%s',
                '%n%n%n%n%n%n%n%n',
                '%.1000d%.1000d%.1000d',
                '%08x.%08x.%08x.%08x',
                '%d%d%d%d%d%d%d%d%d%d',
                '%x.%x.%x.%x.%x.%x.%x'
            ],

            // Integer overflow patterns
            integerOverflow: [
                '2147483647',    // MAX_INT
                '2147483648',    // MAX_INT + 1
                '4294967295',    // MAX_UINT
                '4294967296',    // MAX_UINT + 1
                '-2147483648',   // MIN_INT
                '-2147483649',   // MIN_INT - 1
                '9223372036854775807',   // MAX_LONG
                '9223372036854775808',   // MAX_LONG + 1
                '-1',
                '0',
                '18446744073709551615'   // MAX_ULONG
            ],

            // Stack-based buffer overflow
            stackOverflow: [
                '\x41' * 100 + '\x42\x42\x42\x42',  // AAAA...BBBB pattern
                '\x41' * 256 + '\x43\x43\x43\x43',  // Extended pattern
                '\x90' * 100 + '\xcc' * 4,          // NOP sled + INT3
                'A' * 200 + 'BCDEFGHIJKLMNOP',      // Pattern for offset calculation
                cyclic_pattern(300),                  // De Bruijn sequence
                'A' * 1000,                          // Large buffer
                '\x00' * 500,                       // Null bytes
                '\xff' * 500                        // High bytes
            ],

            // Heap-based buffer overflow
            heapOverflow: [
                'A' * 0x1000,                       // 4KB overflow
                'B' * 0x2000,                       // 8KB overflow
                'C' * 0x4000,                       // 16KB overflow
                '\x41\x41\x41\x41' * 1000,         // Repeated AAAA
                create_heap_spray_pattern(1000),     // Heap spray pattern
                'X' * 0x10000                       // 64KB overflow
            ],

            // Unicode/UTF-8 overflow
            unicodeOverflow: [
                '\u0041' * 500,                     // Unicode A
                '\u00c0\u00ae' * 250,              // Overlong UTF-8
                '\ud800\udc00' * 250,              // UTF-16 surrogate pairs
                '\uff21' * 500,                     // Fullwidth A
                '\u0100' * 500,                     // Latin Extended-A
                encodeURIComponent('A' * 1000),     // URL encoded
                Buffer.from('A'.repeat(1000), 'utf16le').toString()
            ],

            // Null byte injection
            nullByteOverflow: [
                'A' * 100 + '\x00' + 'A' * 100,
                'A' * 256 + '\x00\x00',
                '\x00' + 'A' * 500,
                'A' * 100 + '\x00' * 10,
                Buffer.alloc(500, 0x41).toString() + '\x00'
            ]
        };

        // Common vulnerable parameters
        this.vulnerableParameters = [
            'name', 'username', 'password', 'email', 'address', 'comment',
            'message', 'data', 'input', 'value', 'text', 'content',
            'buffer', 'string', 'field', 'param', 'arg', 'var',
            'file', 'filename', 'path', 'url', 'query', 'search'
        ];

        // Buffer overflow indicators in responses
        this.overflowIndicators = [
            // Segmentation fault indicators
            /segmentation fault/i,
            /segfault/i,
            /sigsegv/i,
            /access violation/i,
            /memory access error/i,
            /buffer overflow/i,
            /stack overflow/i,
            /heap corruption/i,

            // Application crash indicators
            /application error/i,
            /runtime error/i,
            /fatal error/i,
            /abnormal termination/i,
            /unexpected error/i,
            /core dumped/i,
            /crashed/i,

            // Debug/Error messages
            /stack trace/i,
            /call stack/i,
            /memory dump/i,
            /exception.*0x[0-9a-f]+/i,
            /error.*0x[0-9a-f]+/i,
            /address.*0x[0-9a-f]+/i,

            // Server errors that might indicate overflow
            /500 internal server error/i,
            /502 bad gateway/i,
            /503 service unavailable/i,
            /connection reset/i,
            /connection closed/i,

            // Format string indicators
            /0x[0-9a-f]{8}/,
            /\([0-9a-fx]+\)/,
            /%[0-9]+\$[dxsp]/
        ];

        // Memory corruption patterns
        this.corruptionPatterns = {
            stackCanary: [
                'A' * 100 + 'canary_bypass',
                'A' * 256 + '\x00\x0a\x0d\xff',
                'overflow' + '\x00' * 4
            ],

            returnAddress: [
                'A' * 268 + '\x41\x41\x41\x41',  // EIP overwrite
                'A' * 1032 + '\x42\x42\x42\x42\x42\x42\x42\x42', // RIP overwrite
                'A' * 512 + '\xde\xad\xbe\xef'   // Specific pattern
            ],

            vtableCorruption: [
                'A' * 100 + '\x08\x04\x06\x02',  // Vtable pointer
                'B' * 200 + '\x10\x08\x0c\x04'   // Object corruption
            ]
        };

        // Fuzzing patterns for automated testing
        this.fuzzPatterns = {
            lengths: [0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384],
            characters: [
                '\x00', '\x01', '\x02', '\x7f', '\x80', '\xff',
                'A', 'a', '0', '!', '@', '#', '$', '%', '^', '&', '*',
                '\n', '\r', '\t', ' ', '\x0a', '\x0d', '\x09'
            ]
        };
    }

    async execute(target, options = {}) {
        try {
            const startTime = Date.now();
            const results = {
                target,
                timestamp: new Date(),
                vulnerabilities: [],
                statistics: {
                    totalTests: 0,
                    bufferOverflows: 0,
                    formatStringVulns: 0,
                    integerOverflows: 0,
                    memoryCorruptions: 0
                },
                detailedResults: {}
            };

            console.log(`[BufferOverflow] Starting buffer overflow scan on: ${target}`);

            // Parse target and identify testable parameters
            const targetInfo = this.parseTarget(target);

            if (!targetInfo.parameters || targetInfo.parameters.length === 0) {
                // If no parameters, test common endpoints
                const endpointResults = await this.testCommonEndpoints(targetInfo, options);
                results.detailedResults.endpointTesting = endpointResults;
                results.statistics.totalTests += endpointResults.tests.length;
                results.vulnerabilities.push(...endpointResults.vulnerabilities);
            } else {
                console.log(`[BufferOverflow] Found ${targetInfo.parameters.length} testable parameters`);

                // Test each parameter with different overflow techniques
                for (const param of targetInfo.parameters) {
                    console.log(`[BufferOverflow] Testing parameter: ${param.name}`);

                    // Basic buffer overflow testing
                    const basicResults = await this.testBasicOverflow(targetInfo, param, options);
                    results.detailedResults[`${param.name}_basic`] = basicResults;
                    results.statistics.totalTests += basicResults.tests.length;
                    results.statistics.bufferOverflows += basicResults.vulnerabilities.length;
                    results.vulnerabilities.push(...basicResults.vulnerabilities);

                    // Format string vulnerability testing
                    const formatResults = await this.testFormatString(targetInfo, param, options);
                    results.detailedResults[`${param.name}_format`] = formatResults;
                    results.statistics.totalTests += formatResults.tests.length;
                    results.statistics.formatStringVulns += formatResults.vulnerabilities.length;
                    results.vulnerabilities.push(...formatResults.vulnerabilities);

                    // Integer overflow testing
                    const integerResults = await this.testIntegerOverflow(targetInfo, param, options);
                    results.detailedResults[`${param.name}_integer`] = integerResults;
                    results.statistics.totalTests += integerResults.tests.length;
                    results.statistics.integerOverflows += integerResults.vulnerabilities.length;
                    results.vulnerabilities.push(...integerResults.vulnerabilities);

                    // Unicode/encoding overflow testing
                    const unicodeResults = await this.testUnicodeOverflow(targetInfo, param, options);
                    results.detailedResults[`${param.name}_unicode`] = unicodeResults;
                    results.statistics.totalTests += unicodeResults.tests.length;
                    results.vulnerabilities.push(...unicodeResults.vulnerabilities);

                    // Advanced memory corruption testing
                    if (options.advancedTesting) {
                        const corruptionResults = await this.testMemoryCorruption(targetInfo, param, options);
                        results.detailedResults[`${param.name}_corruption`] = corruptionResults;
                        results.statistics.totalTests += corruptionResults.tests.length;
                        results.statistics.memoryCorruptions += corruptionResults.vulnerabilities.length;
                        results.vulnerabilities.push(...corruptionResults.vulnerabilities);
                    }
                }
            }

            // Fuzzing testing if enabled
            if (options.enableFuzzing && targetInfo.parameters.length > 0) {
                const fuzzResults = await this.performFuzzing(targetInfo, options);
                results.detailedResults.fuzzing = fuzzResults;
                results.statistics.totalTests += fuzzResults.tests.length;
                results.vulnerabilities.push(...fuzzResults.vulnerabilities);
            }

            results.executionTime = Date.now() - startTime;
            console.log(`[BufferOverflow] Scan completed. Found ${results.vulnerabilities.length} vulnerabilities in ${results.executionTime}ms`);

            return results;

        } catch (error) {
            console.error('[BufferOverflow] Scan failed:', error.message);
            throw error;
        }
    }

    parseTarget(target) {
        try {
            const url = new URL(target);
            const parameters = [];

            // Extract URL parameters
            for (const [name, value] of url.searchParams.entries()) {
                parameters.push({
                    name,
                    value,
                    type: 'url',
                    location: 'query',
                    suspicious: this.vulnerableParameters.includes(name.toLowerCase())
                });
            }

            return {
                protocol: url.protocol,
                host: url.host,
                pathname: url.pathname,
                search: url.search,
                parameters,
                baseUrl: `${url.protocol}//${url.host}${url.pathname}`
            };
        } catch (error) {
            throw new Error(`Invalid target URL: ${error.message}`);
        }
    }

    async testBasicOverflow(targetInfo, param, options) {
        const results = {
            type: 'basic_overflow',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[BufferOverflow] Testing basic overflow on parameter: ${param.name}`);

        for (const payload of this.overflowPatterns.basic) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const response = await this.makeRequest(testUrl, 'GET', {}, options);

                const testResult = {
                    payload: payload.substring(0, 50) + '...',
                    payloadLength: payload.length,
                    url: testUrl,
                    statusCode: response.status,
                    responseTime: response.responseTime,
                    overflowDetected: this.detectBufferOverflow(response),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.overflowDetected) {
                    const vulnerability = {
                        type: 'Buffer Overflow',
                        subtype: 'Basic Buffer Overflow',
                        severity: 'critical',
                        parameter: param.name,
                        payloadLength: payload.length,
                        evidence: this.extractOverflowEvidence(response),
                        impact: 'Potential arbitrary code execution through buffer overflow',
                        recommendation: 'Implement proper bounds checking and use safe string functions',
                        cwe: 'CWE-120',
                        owasp: 'A06:2021 – Vulnerable and Outdated Components'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[BufferOverflow] Buffer overflow detected: ${param.name} with ${payload.length} bytes`);
                }

            } catch (error) {
                results.tests.push({
                    payload: payload.substring(0, 50) + '...',
                    payloadLength: payload.length,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testFormatString(targetInfo, param, options) {
        const results = {
            type: 'format_string',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[BufferOverflow] Testing format string on parameter: ${param.name}`);

        for (const payload of this.overflowPatterns.formatString) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const response = await this.makeRequest(testUrl, 'GET', {}, options);

                const testResult = {
                    payload,
                    url: testUrl,
                    statusCode: response.status,
                    formatStringDetected: this.detectFormatString(response),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.formatStringDetected) {
                    const vulnerability = {
                        type: 'Format String Vulnerability',
                        subtype: 'Format String Attack',
                        severity: 'high',
                        parameter: param.name,
                        payload,
                        evidence: this.extractFormatStringEvidence(response),
                        impact: 'Information disclosure and potential code execution',
                        recommendation: 'Never use user input directly in format strings',
                        cwe: 'CWE-134',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[BufferOverflow] Format string vulnerability detected: ${param.name}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testIntegerOverflow(targetInfo, param, options) {
        const results = {
            type: 'integer_overflow',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[BufferOverflow] Testing integer overflow on parameter: ${param.name}`);

        for (const payload of this.overflowPatterns.integerOverflow) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const response = await this.makeRequest(testUrl, 'GET', {}, options);

                const testResult = {
                    payload,
                    url: testUrl,
                    statusCode: response.status,
                    integerOverflowDetected: this.detectIntegerOverflow(response),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.integerOverflowDetected) {
                    const vulnerability = {
                        type: 'Integer Overflow',
                        subtype: 'Integer Boundary Violation',
                        severity: 'high',
                        parameter: param.name,
                        payload,
                        evidence: this.extractOverflowEvidence(response),
                        impact: 'Integer overflow can lead to buffer overflows and memory corruption',
                        recommendation: 'Implement proper integer range validation',
                        cwe: 'CWE-190',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[BufferOverflow] Integer overflow detected: ${param.name} with value ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testUnicodeOverflow(targetInfo, param, options) {
        const results = {
            type: 'unicode_overflow',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[BufferOverflow] Testing unicode overflow on parameter: ${param.name}`);

        for (const payload of this.overflowPatterns.unicodeOverflow) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const response = await this.makeRequest(testUrl, 'GET', {}, options);

                const testResult = {
                    payload: payload.substring(0, 50) + '...',
                    payloadLength: payload.length,
                    url: testUrl,
                    statusCode: response.status,
                    unicodeOverflowDetected: this.detectBufferOverflow(response),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.unicodeOverflowDetected) {
                    const vulnerability = {
                        type: 'Unicode Buffer Overflow',
                        subtype: 'Unicode/UTF-8 Overflow',
                        severity: 'high',
                        parameter: param.name,
                        payloadLength: payload.length,
                        evidence: this.extractOverflowEvidence(response),
                        impact: 'Unicode handling vulnerabilities can bypass filters',
                        recommendation: 'Implement proper Unicode validation and normalization',
                        cwe: 'CWE-120',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[BufferOverflow] Unicode overflow detected: ${param.name}`);
                }

            } catch (error) {
                results.tests.push({
                    payload: payload.substring(0, 50) + '...',
                    payloadLength: payload.length,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testMemoryCorruption(targetInfo, param, options) {
        const results = {
            type: 'memory_corruption',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[BufferOverflow] Testing memory corruption on parameter: ${param.name}`);

        for (const [corruptionType, payloads] of Object.entries(this.corruptionPatterns)) {
            for (const payload of payloads) {
                try {
                    const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                    const response = await this.makeRequest(testUrl, 'GET', {}, options);

                    const testResult = {
                        corruptionType,
                        payload: payload.substring(0, 50) + '...',
                        url: testUrl,
                        statusCode: response.status,
                        corruptionDetected: this.detectMemoryCorruption(response),
                        timestamp: new Date()
                    };

                    results.tests.push(testResult);

                    if (testResult.corruptionDetected) {
                        const vulnerability = {
                            type: 'Memory Corruption',
                            subtype: `${corruptionType} Corruption`,
                            severity: 'critical',
                            parameter: param.name,
                            corruptionType,
                            evidence: this.extractOverflowEvidence(response),
                            impact: 'Memory corruption can lead to arbitrary code execution',
                            recommendation: 'Implement stack protection and memory safety measures',
                            cwe: 'CWE-119',
                            owasp: 'A06:2021 – Vulnerable and Outdated Components'
                        };
                        results.vulnerabilities.push(vulnerability);
                        console.log(`[BufferOverflow] Memory corruption detected: ${corruptionType} in ${param.name}`);
                    }

                } catch (error) {
                    results.tests.push({
                        corruptionType,
                        payload: payload.substring(0, 50) + '...',
                        error: error.message,
                        timestamp: new Date()
                    });
                }

                if (options.delay) {
                    await this.sleep(options.delay);
                }
            }
        }

        return results;
    }

    async testCommonEndpoints(targetInfo, options) {
        const results = {
            tests: [],
            vulnerabilities: []
        };

        console.log(`[BufferOverflow] Testing common vulnerable endpoints`);

        const commonEndpoints = [
            '/search',
            '/login',
            '/contact',
            '/feedback',
            '/comment',
            '/upload',
            '/process',
            '/submit'
        ];

        for (const endpoint of commonEndpoints) {
            const testUrl = `${targetInfo.baseUrl}${endpoint}`;

            // Test with POST data
            const postData = {
                data: 'A'.repeat(1000),
                input: 'B'.repeat(2000),
                message: 'C'.repeat(500)
            };

            try {
                const response = await this.makeRequest(testUrl, 'POST', postData, options);

                const testResult = {
                    endpoint,
                    method: 'POST',
                    statusCode: response.status,
                    overflowDetected: this.detectBufferOverflow(response),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.overflowDetected) {
                    results.vulnerabilities.push({
                        type: 'Buffer Overflow',
                        subtype: 'Endpoint Buffer Overflow',
                        severity: 'critical',
                        endpoint,
                        evidence: this.extractOverflowEvidence(response),
                        impact: 'Buffer overflow in common endpoint',
                        recommendation: 'Implement input validation for all endpoints',
                        cwe: 'CWE-120',
                        owasp: 'A06:2021 – Vulnerable and Outdated Components'
                    });
                }

            } catch (error) {
                results.tests.push({
                    endpoint,
                    method: 'POST',
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async performFuzzing(targetInfo, options) {
        const results = {
            tests: [],
            vulnerabilities: []
        };

        console.log(`[BufferOverflow] Performing fuzzing tests`);

        const testParam = targetInfo.parameters[0]; // Test first parameter

        for (const length of this.fuzzPatterns.lengths) {
            for (const char of this.fuzzPatterns.characters.slice(0, 5)) { // Limit for performance
                try {
                    const payload = char.repeat(length);
                    const testUrl = this.buildTestUrl(targetInfo, testParam.name, payload);
                    const response = await this.makeRequest(testUrl, 'GET', {}, options);

                    const testResult = {
                        fuzzType: 'length_char_combination',
                        character: char,
                        length,
                        statusCode: response.status,
                        anomalyDetected: this.detectAnomalies(response, length),
                        timestamp: new Date()
                    };

                    results.tests.push(testResult);

                    if (testResult.anomalyDetected) {
                        results.vulnerabilities.push({
                            type: 'Fuzzing Anomaly',
                            subtype: 'Abnormal Response',
                            severity: 'medium',
                            parameter: testParam.name,
                            character: char,
                            length,
                            evidence: `Anomaly with ${length} repetitions of character ${char}`,
                            impact: 'Fuzzing revealed abnormal application behavior',
                            recommendation: 'Investigate and fix input handling for edge cases',
                            cwe: 'CWE-20',
                            owasp: 'A03:2021 – Injection'
                        });
                    }

                } catch (error) {
                    results.tests.push({
                        fuzzType: 'length_char_combination',
                        character: char,
                        length,
                        error: error.message,
                        timestamp: new Date()
                    });
                }

                if (options.delay) {
                    await this.sleep(options.delay);
                }
            }
        }

        return results;
    }

    // Detection methods
    detectBufferOverflow(response) {
        if (!response.data) return false;

        // Check for buffer overflow indicators
        return this.overflowIndicators.some(indicator => indicator.test(response.data)) ||
               this.isServerCrash(response.status) ||
               this.hasAbnormalResponseTime(response.responseTime);
    }

    detectFormatString(response) {
        if (!response.data) return false;

        // Look for format string output patterns
        const formatPatterns = [
            /0x[0-9a-f]{8}/gi,
            /\b[0-9a-f]{8}\b/gi,
            /%[0-9]+\$[dxsp]/gi,
            /\([0-9a-fx]+\)/gi
        ];

        return formatPatterns.some(pattern => pattern.test(response.data));
    }

    detectIntegerOverflow(response) {
        if (!response.data) return false;

        // Check for integer overflow indicators
        const integerOverflowPatterns = [
            /integer overflow/i,
            /arithmetic overflow/i,
            /numeric overflow/i,
            /value too large/i,
            /out of range/i
        ];

        return integerOverflowPatterns.some(pattern => pattern.test(response.data)) ||
               this.detectBufferOverflow(response);
    }

    detectMemoryCorruption(response) {
        if (!response.data) return false;

        const corruptionPatterns = [
            /heap corruption/i,
            /stack corruption/i,
            /memory corruption/i,
            /double free/i,
            /use after free/i,
            /invalid pointer/i
        ];

        return corruptionPatterns.some(pattern => pattern.test(response.data)) ||
               this.isServerCrash(response.status);
    }

    detectAnomalies(response, inputLength) {
        // Detect abnormal responses during fuzzing
        return this.isServerCrash(response.status) ||
               this.hasAbnormalResponseTime(response.responseTime) ||
               (response.data && this.overflowIndicators.some(indicator => indicator.test(response.data)));
    }

    isServerCrash(statusCode) {
        return [500, 502, 503, 504].includes(statusCode);
    }

    hasAbnormalResponseTime(responseTime) {
        return responseTime > 30000; // More than 30 seconds might indicate hanging
    }

    extractOverflowEvidence(response) {
        if (!response.data) {
            return `HTTP ${response.status} - No response data`;
        }

        // Find specific overflow indicators
        for (const indicator of this.overflowIndicators) {
            const match = response.data.match(indicator);
            if (match) {
                return `Overflow indicator found: ${match[0]}`;
            }
        }

        return response.data.substring(0, 200) + (response.data.length > 200 ? '...' : '');
    }

    extractFormatStringEvidence(response) {
        if (!response.data) return 'No response data';

        // Look for hexadecimal values that indicate format string exploitation
        const hexMatches = response.data.match(/0x[0-9a-f]{8}/gi);
        if (hexMatches && hexMatches.length > 3) {
            return `Format string leak detected: ${hexMatches.slice(0, 3).join(', ')}`;
        }

        return this.extractOverflowEvidence(response);
    }

    buildTestUrl(targetInfo, paramName, payload) {
        const url = new URL(targetInfo.baseUrl);

        // Set original parameters
        for (const param of targetInfo.parameters) {
            if (param.name === paramName) {
                url.searchParams.set(param.name, payload);
            } else {
                url.searchParams.set(param.name, param.value);
            }
        }

        return url.toString();
    }

    async makeRequest(url, method = 'GET', data = {}, options = {}) {
        const startTime = Date.now();

        const requestOptions = {
            method: method.toUpperCase(),
            url,
            timeout: options.timeout || 30000,
            headers: {
                'User-Agent': options.userAgent || 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                ...options.headers
            },
            validateStatus: () => true // Accept all status codes
        };

        if (method.toUpperCase() !== 'GET' && Object.keys(data).length > 0) {
            requestOptions.data = data;
            requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }

        const response = await axios(requestOptions);
        response.responseTime = Date.now() - startTime;
        return response;
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async getInfo() {
        return {
            name: this.displayName,
            description: this.description,
            version: this.version,
            severity: this.severity,
            category: this.category,
            techniques: [
                'Basic Buffer Overflow',
                'Format String Vulnerabilities',
                'Integer Overflow',
                'Unicode/UTF-8 Overflow',
                'Stack-based Overflow',
                'Heap-based Overflow',
                'Memory Corruption',
                'Fuzzing'
            ],
            parameters: [
                {
                    name: 'delay',
                    description: 'Delay between requests in milliseconds',
                    type: 'number',
                    default: 100
                },
                {
                    name: 'timeout',
                    description: 'Request timeout in milliseconds',
                    type: 'number',
                    default: 30000
                },
                {
                    name: 'advancedTesting',
                    description: 'Enable advanced memory corruption testing',
                    type: 'boolean',
                    default: false
                },
                {
                    name: 'enableFuzzing',
                    description: 'Enable automated fuzzing tests',
                    type: 'boolean',
                    default: false
                },
                {
                    name: 'userAgent',
                    description: 'Custom User-Agent header',
                    type: 'string',
                    default: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
                }
            ],
            payloadTypes: Object.keys(this.overflowPatterns).length,
            overflowIndicators: this.overflowIndicators.length,
            vulnerableParameters: this.vulnerableParameters.length
        };
    }
}

// Helper functions for pattern generation
function cyclic_pattern(length) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let pattern = '';
    for (let i = 0; i < length; i++) {
        pattern += chars[i % chars.length];
    }
    return pattern;
}

function create_heap_spray_pattern(count) {
    const block = '\x90\x90\x90\x90\x41\x41\x41\x41'; // NOP + AAAA
    return block.repeat(count);
}

module.exports = BufferOverflowExploit;
