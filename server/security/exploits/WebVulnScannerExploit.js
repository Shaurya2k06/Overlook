const axios = require('axios');
const cheerio = require('cheerio');
const crypto = require('crypto');

class WebVulnScannerExploit {
    constructor() {
        this.displayName = 'Web Vulnerability Scanner';
        this.description = 'Comprehensive web application vulnerability scanner';
        this.severity = 'high';
        this.category = 'web-application';
        this.version = '2.0.0';

        // Common web vulnerabilities to scan for
        this.vulnerabilityTypes = {
            // Information disclosure
            informationDisclosure: [
                '/.git/',
                '/.svn/',
                '/.env',
                '/config.php',
                '/wp-config.php',
                '/database.yml',
                '/config/database.yml',
                '/backup.sql',
                '/dump.sql',
                '/phpinfo.php',
                '/info.php',
                '/test.php',
                '/debug.php',
                '/robots.txt',
                '/sitemap.xml',
                '/.htaccess',
                '/web.config',
                '/crossdomain.xml',
                '/clientaccesspolicy.xml'
            ],

            // Admin panels and login pages
            adminPanels: [
                '/admin/',
                '/admin/login',
                '/administrator/',
                '/wp-admin/',
                '/cpanel/',
                '/phpmyadmin/',
                '/adminer/',
                '/management/',
                '/manager/',
                '/console/',
                '/control/',
                '/portal/',
                '/dashboard/',
                '/backend/',
                '/cms/',
                '/login.php',
                '/admin.php',
                '/administrator.php'
            ],

            // Backup and temporary files
            backupFiles: [
                '/backup.zip',
                '/backup.tar.gz',
                '/backup.sql',
                '/database.sql',
                '/dump.sql',
                '/site.zip',
                '/www.zip',
                '/backup/',
                '/backups/',
                '/old/',
                '/temp/',
                '/tmp/',
                '/_backup/',
                '/_old/',
                '/config.bak',
                '/database.bak',
                '/index.php.bak',
                '/web.config.bak'
            ],

            // Development and debug files
            debugFiles: [
                '/debug.log',
                '/error.log',
                '/access.log',
                '/application.log',
                '/debug/',
                '/logs/',
                '/log/',
                '/trace/',
                '/errors/',
                '/test/',
                '/dev/',
                '/development/',
                '/staging/',
                '/beta/',
                '/demo/',
                '/sample/'
            ],

            // Common CMS vulnerabilities
            cmsVulns: [
                '/wp-content/uploads/',
                '/wp-includes/',
                '/wp-admin/install.php',
                '/wp-config.php.bak',
                '/sites/default/files/',
                '/modules/',
                '/themes/',
                '/plugins/',
                '/install.php',
                '/upgrade.php',
                '/setup.php',
                '/install/',
                '/setup/'
            ]
        };

        // HTTP methods to test
        this.httpMethods = [
            'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'
        ];

        // Security headers to check
        this.securityHeaders = [
            'X-Frame-Options',
            'X-XSS-Protection',
            'X-Content-Type-Options',
            'Content-Security-Policy',
            'Strict-Transport-Security',
            'Referrer-Policy',
            'Feature-Policy',
            'Permissions-Policy'
        ];

        // Common error patterns
        this.errorPatterns = [
            // Database errors
            /SQL syntax.*MySQL/i,
            /Warning.*mysql_/i,
            /valid MySQL result/i,
            /MySqlClient\./i,
            /PostgreSQL.*ERROR/i,
            /Warning.*pg_/i,
            /valid PostgreSQL result/i,
            /ORA-[0-9]+/i,
            /Microsoft.*ODBC.*SQL Server/i,
            /SQLite.*error/i,

            // Application errors
            /Fatal error/i,
            /Parse error/i,
            /Warning:/i,
            /Notice:/i,
            /Undefined variable/i,
            /Undefined index/i,
            /Call to undefined function/i,
            /Stack trace:/i,
            /Exception.*in.*line/i,

            // Server errors
            /Internal Server Error/i,
            /Server Error/i,
            /Apache.*Error/i,
            /Nginx.*Error/i,
            /IIS.*Error/i,

            // Framework errors
            /Laravel.*Exception/i,
            /CodeIgniter.*Error/i,
            /CakePHP.*Error/i,
            /Symfony.*Exception/i,
            /Django.*Error/i,
            /Flask.*Error/i,
            /Express.*Error/i
        ];

        // File inclusion patterns
        this.fileInclusionPatterns = [
            '../',
            '..\\',
            '/etc/passwd',
            'C:\\Windows\\win.ini',
            'php://filter',
            'php://input',
            'data://',
            'file://',
            'expect://',
            'zip://'
        ];

        // Common injection payloads
        this.injectionPayloads = [
            "'",
            '"',
            '<script>',
            '<?php',
            '${',
            '{{',
            '<%',
            '#{'
        ];
    }

    async execute(target, options = {}) {
        try {
            const startTime = Date.now();
            const results = {
                target,
                timestamp: new Date(),
                vulnerabilities: [],
                statistics: {
                    totalTests: 0,
                    informationDisclosures: 0,
                    securityMisconfigurations: 0,
                    errorDisclosures: 0,
                    httpMethodIssues: 0
                },
                detailedResults: {}
            };

            console.log(`[WebVuln] Starting web vulnerability scan on: ${target}`);

            // Parse target URL
            const targetInfo = this.parseTarget(target);

            // Step 1: Information disclosure testing
            const infoResults = await this.testInformationDisclosure(targetInfo, options);
            results.detailedResults.informationDisclosure = infoResults;
            results.statistics.totalTests += infoResults.tests.length;
            results.statistics.informationDisclosures = infoResults.vulnerabilities.length;
            results.vulnerabilities.push(...infoResults.vulnerabilities);

            // Step 2: Security headers analysis
            const headerResults = await this.analyzeSecurityHeaders(targetInfo, options);
            results.detailedResults.securityHeaders = headerResults;
            results.statistics.totalTests += headerResults.tests.length;
            results.statistics.securityMisconfigurations += headerResults.vulnerabilities.length;
            results.vulnerabilities.push(...headerResults.vulnerabilities);

            // Step 3: HTTP methods testing
            const methodResults = await this.testHttpMethods(targetInfo, options);
            results.detailedResults.httpMethods = methodResults;
            results.statistics.totalTests += methodResults.tests.length;
            results.statistics.httpMethodIssues = methodResults.vulnerabilities.length;
            results.vulnerabilities.push(...methodResults.vulnerabilities);

            // Step 4: Error-based information disclosure
            const errorResults = await this.testErrorDisclosure(targetInfo, options);
            results.detailedResults.errorDisclosure = errorResults;
            results.statistics.totalTests += errorResults.tests.length;
            results.statistics.errorDisclosures = errorResults.vulnerabilities.length;
            results.vulnerabilities.push(...errorResults.vulnerabilities);

            // Step 5: Basic injection testing
            const injectionResults = await this.testBasicInjections(targetInfo, options);
            results.detailedResults.basicInjections = injectionResults;
            results.statistics.totalTests += injectionResults.tests.length;
            results.vulnerabilities.push(...injectionResults.vulnerabilities);

            // Step 6: File inclusion testing
            const fileInclusionResults = await this.testFileInclusion(targetInfo, options);
            results.detailedResults.fileInclusion = fileInclusionResults;
            results.statistics.totalTests += fileInclusionResults.tests.length;
            results.vulnerabilities.push(...fileInclusionResults.vulnerabilities);

            // Step 7: CMS-specific testing
            const cmsResults = await this.testCMSVulnerabilities(targetInfo, options);
            results.detailedResults.cmsVulnerabilities = cmsResults;
            results.statistics.totalTests += cmsResults.tests.length;
            results.vulnerabilities.push(...cmsResults.vulnerabilities);

            results.executionTime = Date.now() - startTime;
            console.log(`[WebVuln] Scan completed. Found ${results.vulnerabilities.length} vulnerabilities in ${results.executionTime}ms`);

            return results;

        } catch (error) {
            console.error('[WebVuln] Scan failed:', error.message);
            throw error;
        }
    }

    parseTarget(target) {
        try {
            const url = new URL(target);
            return {
                original: target,
                protocol: url.protocol,
                hostname: url.hostname,
                port: url.port,
                pathname: url.pathname,
                search: url.search,
                baseUrl: `${url.protocol}//${url.hostname}${url.port ? ':' + url.port : ''}`,
                fullUrl: url.toString()
            };
        } catch (error) {
            throw new Error(`Invalid target URL: ${error.message}`);
        }
    }

    async testInformationDisclosure(targetInfo, options) {
        const results = {
            tests: [],
            vulnerabilities: []
        };

        console.log(`[WebVuln] Testing information disclosure vulnerabilities`);

        const allPaths = [
            ...this.vulnerabilityTypes.informationDisclosure,
            ...this.vulnerabilityTypes.backupFiles,
            ...this.vulnerabilityTypes.debugFiles
        ];

        for (const path of allPaths) {
            try {
                const testUrl = `${targetInfo.baseUrl}${path}`;
                const response = await this.makeRequest(testUrl, 'GET', {}, options);

                const testResult = {
                    path,
                    url: testUrl,
                    statusCode: response.status,
                    responseLength: response.data ? response.data.length : 0,
                    accessible: response.status === 200,
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (response.status === 200 && response.data) {
                    const severity = this.assessInformationDisclosureSeverity(path, response.data);

                    if (severity !== 'info') {
                        results.vulnerabilities.push({
                            type: 'Information Disclosure',
                            subtype: this.categorizeDisclosure(path),
                            severity,
                            path,
                            url: testUrl,
                            evidence: this.extractDisclosureEvidence(response.data),
                            impact: this.getDisclosureImpact(path),
                            recommendation: 'Remove or restrict access to sensitive files and directories',
                            cwe: 'CWE-200',
                            owasp: 'A01:2021 – Broken Access Control'
                        });
                        console.log(`[WebVuln] Information disclosure found: ${path}`);
                    }
                }

            } catch (error) {
                results.tests.push({
                    path,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async analyzeSecurityHeaders(targetInfo, options) {
        const results = {
            tests: [],
            vulnerabilities: []
        };

        console.log(`[WebVuln] Analyzing security headers`);

        try {
            const response = await this.makeRequest(targetInfo.fullUrl, 'GET', {}, options);

            for (const header of this.securityHeaders) {
                const headerValue = response.headers[header.toLowerCase()];

                const testResult = {
                    header,
                    present: !!headerValue,
                    value: headerValue,
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (!headerValue) {
                    const severity = this.getHeaderSeverity(header);
                    results.vulnerabilities.push({
                        type: 'Security Misconfiguration',
                        subtype: `Missing ${header}`,
                        severity,
                        header,
                        evidence: `${header} header is not present`,
                        impact: this.getHeaderImpact(header),
                        recommendation: `Implement ${header} security header`,
                        cwe: 'CWE-16',
                        owasp: 'A05:2021 – Security Misconfiguration'
                    });
                } else {
                    // Analyze header value for misconfigurations
                    const headerAnalysis = this.analyzeHeaderValue(header, headerValue);
                    if (headerAnalysis.issue) {
                        results.vulnerabilities.push({
                            type: 'Security Misconfiguration',
                            subtype: `Weak ${header}`,
                            severity: headerAnalysis.severity,
                            header,
                            value: headerValue,
                            evidence: headerAnalysis.evidence,
                            impact: headerAnalysis.impact,
                            recommendation: headerAnalysis.recommendation,
                            cwe: 'CWE-16',
                            owasp: 'A05:2021 – Security Misconfiguration'
                        });
                    }
                }
            }

        } catch (error) {
            results.tests.push({
                test: 'security_headers_analysis',
                error: error.message,
                timestamp: new Date()
            });
        }

        return results;
    }

    async testHttpMethods(targetInfo, options) {
        const results = {
            tests: [],
            vulnerabilities: []
        };

        console.log(`[WebVuln] Testing HTTP methods`);

        for (const method of this.httpMethods) {
            try {
                const response = await this.makeRequest(targetInfo.fullUrl, method, {}, options);

                const testResult = {
                    method,
                    statusCode: response.status,
                    allowed: response.status !== 405 && response.status !== 501,
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                // Check for dangerous methods
                if (this.isDangerousMethod(method) && testResult.allowed) {
                    results.vulnerabilities.push({
                        type: 'Security Misconfiguration',
                        subtype: `Dangerous HTTP Method`,
                        severity: this.getMethodSeverity(method),
                        method,
                        evidence: `${method} method is allowed (Status: ${response.status})`,
                        impact: this.getMethodImpact(method),
                        recommendation: `Disable ${method} method if not required`,
                        cwe: 'CWE-16',
                        owasp: 'A05:2021 – Security Misconfiguration'
                    });
                    console.log(`[WebVuln] Dangerous HTTP method allowed: ${method}`);
                }

            } catch (error) {
                results.tests.push({
                    method,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testErrorDisclosure(targetInfo, options) {
        const results = {
            tests: [],
            vulnerabilities: []
        };

        console.log(`[WebVuln] Testing error-based information disclosure`);

        const errorTriggers = [
            '?id=\'',
            '?page=999999',
            '?file=nonexistent',
            '/?error=true',
            '/nonexistent_page_12345',
            '/?debug=1',
            '/?test=<script>',
            '/?param[]='
        ];

        for (const trigger of errorTriggers) {
            try {
                const testUrl = `${targetInfo.baseUrl}${trigger}`;
                const response = await this.makeRequest(testUrl, 'GET', {}, options);

                const testResult = {
                    trigger,
                    url: testUrl,
                    statusCode: response.status,
                    hasError: this.detectErrorMessages(response.data),
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (testResult.hasError) {
                    const errorDetails = this.extractErrorDetails(response.data);
                    results.vulnerabilities.push({
                        type: 'Information Disclosure',
                        subtype: 'Error Message Disclosure',
                        severity: 'medium',
                        trigger,
                        url: testUrl,
                        evidence: errorDetails,
                        impact: 'Error messages reveal sensitive system information',
                        recommendation: 'Implement proper error handling and disable debug information',
                        cwe: 'CWE-209',
                        owasp: 'A09:2021 – Security Logging and Monitoring Failures'
                    });
                    console.log(`[WebVuln] Error disclosure found with trigger: ${trigger}`);
                }

            } catch (error) {
                results.tests.push({
                    trigger,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testBasicInjections(targetInfo, options) {
        const results = {
            tests: [],
            vulnerabilities: []
        };

        console.log(`[WebVuln] Testing basic injection vulnerabilities`);

        // Extract parameters from URL
        const url = new URL(targetInfo.fullUrl);
        const parameters = Array.from(url.searchParams.keys());

        if (parameters.length === 0) {
            console.log(`[WebVuln] No parameters found for injection testing`);
            return results;
        }

        for (const param of parameters) {
            for (const payload of this.injectionPayloads) {
                try {
                    const testUrl = new URL(targetInfo.fullUrl);
                    testUrl.searchParams.set(param, payload);

                    const response = await this.makeRequest(testUrl.toString(), 'GET', {}, options);

                    const testResult = {
                        parameter: param,
                        payload,
                        url: testUrl.toString(),
                        statusCode: response.status,
                        reflected: this.isPayloadReflected(response.data, payload),
                        hasError: this.detectErrorMessages(response.data),
                        timestamp: new Date()
                    };

                    results.tests.push(testResult);

                    if (testResult.reflected || testResult.hasError) {
                        results.vulnerabilities.push({
                            type: 'Injection Vulnerability',
                            subtype: this.categorizeInjection(payload),
                            severity: 'medium',
                            parameter: param,
                            payload,
                            evidence: testResult.reflected ?
                                `Payload reflected: ${payload}` :
                                `Error triggered by payload: ${payload}`,
                            impact: 'Potential injection vulnerability detected',
                            recommendation: 'Implement proper input validation and output encoding',
                            cwe: 'CWE-79',
                            owasp: 'A03:2021 – Injection'
                        });
                        console.log(`[WebVuln] Potential injection found in parameter: ${param} with payload: ${payload}`);
                    }

                } catch (error) {
                    results.tests.push({
                        parameter: param,
                        payload,
                        error: error.message,
                        timestamp: new Date()
                    });
                }

                if (options.delay) {
                    await this.sleep(options.delay);
                }
            }
        }

        return results;
    }

    async testFileInclusion(targetInfo, options) {
        const results = {
            tests: [],
            vulnerabilities: []
        };

        console.log(`[WebVuln] Testing file inclusion vulnerabilities`);

        const url = new URL(targetInfo.fullUrl);
        const parameters = Array.from(url.searchParams.keys());

        if (parameters.length === 0) {
            return results;
        }

        for (const param of parameters) {
            for (const payload of this.fileInclusionPatterns) {
                try {
                    const testUrl = new URL(targetInfo.fullUrl);
                    testUrl.searchParams.set(param, payload);

                    const response = await this.makeRequest(testUrl.toString(), 'GET', {}, options);

                    const testResult = {
                        parameter: param,
                        payload,
                        url: testUrl.toString(),
                        statusCode: response.status,
                        vulnerable: this.detectFileInclusion(response.data, payload),
                        timestamp: new Date()
                    };

                    results.tests.push(testResult);

                    if (testResult.vulnerable) {
                        results.vulnerabilities.push({
                            type: 'File Inclusion',
                            subtype: this.categorizeFileInclusion(payload),
                            severity: 'high',
                            parameter: param,
                            payload,
                            evidence: this.extractFileInclusionEvidence(response.data),
                            impact: 'File inclusion vulnerability allows access to system files',
                            recommendation: 'Implement proper input validation and use whitelisting for file operations',
                            cwe: 'CWE-98',
                            owasp: 'A01:2021 – Broken Access Control'
                        });
                        console.log(`[WebVuln] File inclusion vulnerability found in parameter: ${param}`);
                    }

                } catch (error) {
                    results.tests.push({
                        parameter: param,
                        payload,
                        error: error.message,
                        timestamp: new Date()
                    });
                }

                if (options.delay) {
                    await this.sleep(options.delay);
                }
            }
        }

        return results;
    }

    async testCMSVulnerabilities(targetInfo, options) {
        const results = {
            tests: [],
            vulnerabilities: []
        };

        console.log(`[WebVuln] Testing CMS-specific vulnerabilities`);

        for (const path of this.vulnerabilityTypes.cmsVulns) {
            try {
                const testUrl = `${targetInfo.baseUrl}${path}`;
                const response = await this.makeRequest(testUrl, 'GET', {}, options);

                const testResult = {
                    path,
                    url: testUrl,
                    statusCode: response.status,
                    accessible: response.status === 200,
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                if (response.status === 200) {
                    const cmsType = this.detectCMSType(path, response.data);
                    if (cmsType) {
                        results.vulnerabilities.push({
                            type: 'CMS Vulnerability',
                            subtype: `${cmsType} Exposure`,
                            severity: 'medium',
                            path,
                            cmsType,
                            evidence: `Accessible ${cmsType} path: ${path}`,
                            impact: 'CMS-specific paths exposed to unauthorized access',
                            recommendation: 'Secure CMS installation and restrict access to sensitive paths',
                            cwe: 'CWE-200',
                            owasp: 'A01:2021 – Broken Access Control'
                        });
                        console.log(`[WebVuln] CMS vulnerability found: ${cmsType} - ${path}`);
                    }
                }

            } catch (error) {
                results.tests.push({
                    path,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    // Helper methods
    assessInformationDisclosureSeverity(path, responseData) {
        if (path.includes('.git') || path.includes('.svn') || path.includes('.env')) {
            return 'critical';
        }
        if (path.includes('config') || path.includes('backup') || path.includes('.sql')) {
            return 'high';
        }
        if (path.includes('debug') || path.includes('log') || path.includes('info.php')) {
            return 'medium';
        }
        return 'low';
    }

    categorizeDisclosure(path) {
        if (path.includes('.git') || path.includes('.svn')) return 'Version Control Exposure';
        if (path.includes('config') || path.includes('.env')) return 'Configuration File Exposure';
        if (path.includes('backup') || path.includes('.sql')) return 'Backup File Exposure';
        if (path.includes('debug') || path.includes('log')) return 'Debug Information Exposure';
        return 'Information Disclosure';
    }

    extractDisclosureEvidence(responseData) {
        return responseData ? responseData.substring(0, 200) + '...' : 'File accessible';
    }

    getDisclosureImpact(path) {
        const impacts = {
            '.git': 'Source code and commit history exposure',
            '.env': 'Environment variables and secrets exposure',
            'config': 'Application configuration disclosure',
            'backup': 'Database and file backups accessible',
            'debug': 'Debug information and error details exposed'
        };

        for (const [key, impact] of Object.entries(impacts)) {
            if (path.includes(key)) return impact;
        }
        return 'Sensitive information disclosure';
    }

    getHeaderSeverity(header) {
        const severityMap = {
            'X-Frame-Options': 'medium',
            'X-XSS-Protection': 'medium',
            'X-Content-Type-Options': 'low',
            'Content-Security-Policy': 'high',
            'Strict-Transport-Security': 'medium'
        };
        return severityMap[header] || 'low';
    }

    getHeaderImpact(header) {
        const impacts = {
            'X-Frame-Options': 'Vulnerable to clickjacking attacks',
            'X-XSS-Protection': 'XSS protection not enabled',
            'Content-Security-Policy': 'No CSP protection against injection attacks',
            'Strict-Transport-Security': 'HTTPS enforcement not implemented'
        };
        return impacts[header] || 'Security header missing';
    }

    analyzeHeaderValue(header, value) {
        // Basic header value analysis
        if (header === 'X-XSS-Protection' && value === '0') {
            return {
                issue: true,
                severity: 'medium',
                evidence: 'XSS protection explicitly disabled',
                impact: 'XSS protection disabled',
                recommendation: 'Enable XSS protection or use CSP'
            };
        }

        if (header === 'X-Frame-Options' && value.toLowerCase() === 'allowall') {
            return {
                issue: true,
                severity: 'high',
                evidence: 'X-Frame-Options set to ALLOWALL',
                impact: 'Page can be framed by any site',
                recommendation: 'Use DENY or SAMEORIGIN'
            };
        }

        return { issue: false };
    }

    isDangerousMethod(method) {
        return ['TRACE', 'CONNECT', 'DELETE', 'PUT', 'PATCH'].includes(method);
    }

    getMethodSeverity(method) {
        const severityMap = {
            'TRACE': 'medium',
            'CONNECT': 'high',
            'DELETE': 'medium',
            'PUT': 'medium',
            'PATCH': 'low'
        };
        return severityMap[method] || 'low';
    }

    getMethodImpact(method) {
        const impacts = {
            'TRACE': 'HTTP TRACE method can reveal sensitive information',
            'CONNECT': 'HTTP CONNECT method can be used for tunneling',
            'DELETE': 'DELETE method may allow unauthorized resource deletion',
            'PUT': 'PUT method may allow unauthorized file uploads'
        };
        return impacts[method] || 'Potentially dangerous HTTP method enabled';
    }

    detectErrorMessages(responseData) {
        if (!responseData) return false;
        return this.errorPatterns.some(pattern => pattern.test(responseData));
    }

    extractErrorDetails(responseData) {
        for (const pattern of this.errorPatterns) {
            const match = responseData.match(pattern);
            if (match) {
                return match[0];
            }
        }
        return 'Error message detected';
    }

    isPayloadReflected(responseData, payload) {
        if (!responseData) return false;
        return responseData.includes(payload);
    }

    categorizeInjection(payload) {
        if (payload.includes('<script>')) return 'XSS';
        if (payload.includes("'") || payload.includes('"')) return 'SQL Injection';
        if (payload.includes('<?php')) return 'Code Injection';
        if (payload.includes('${') || payload.includes('{{')) return 'Template Injection';
        return 'Injection';
    }

    detectFileInclusion(responseData, payload) {
        if (!responseData) return false;

        // Check for common file inclusion indicators
        const indicators = [
            /root:.*:0:0:/,  // /etc/passwd
            /\[fonts\]/i,    // win.ini
            /Warning.*include/i,
            /Fatal error.*include/i,
            /No such file or directory/i
        ];

        return indicators.some(indicator => indicator.test(responseData));
    }

    categorizeFileInclusion(payload) {
        if (payload.includes('../')) return 'Local File Inclusion';
        if (payload.includes('php://')) return 'PHP Wrapper';
        if (payload.includes('file://')) return 'File Protocol';
        if (payload.includes('data://')) return 'Data Protocol';
        return 'File Inclusion';
    }

    extractFileInclusionEvidence(responseData) {
        // Look for specific file content patterns
        const patterns = [
            /root:.*:0:0:.*/,
            /\[fonts\].*/i,
            /Warning.*include.*/i
        ];

        for (const pattern of patterns) {
            const match = responseData.match(pattern);
            if (match) {
                return match[0];
            }
        }

        return responseData ? responseData.substring(0, 200) : 'File inclusion detected';
    }

    detectCMSType(path, responseData) {
        if (path.includes('wp-')) return 'WordPress';
        if (path.includes('sites/default')) return 'Drupal';
        if (path.includes('modules/') || path.includes('themes/')) return 'CMS';
        return null;
    }

    async makeRequest(url, method = 'GET', data = {}, options = {}) {
        const requestOptions = {
            method: method.toUpperCase(),
            url,
            timeout: options.timeout || 10000,
            headers: {
                'User-Agent': options.userAgent || 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                ...options.headers
            },
            validateStatus: () => true // Accept all status codes
        };

        if (method.toUpperCase() !== 'GET' && Object.keys(data).length > 0) {
            requestOptions.data = data;
        }

        return await axios(requestOptions);
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async getInfo() {
        return {
            name: this.displayName,
            description: this.description,
            version: this.version,
            severity: this.severity,
            category: this.category,
            vulnerabilityTypes: [
                'Information Disclosure',
                'Security Misconfiguration',
                'Error-based Information Disclosure',
                'Basic Injection Testing',
                'File Inclusion Vulnerabilities',
                'CMS-specific Vulnerabilities'
            ],
            parameters: [
                {
                    name: 'delay',
                    description: 'Delay between requests in milliseconds',
                    type: 'number',
                    default: 100
                },
                {
                    name: 'timeout',
                    description: 'Request timeout in milliseconds',
                    type: 'number',
                    default: 10000
                },
                {
                    name: 'userAgent',
                    description: 'Custom User-Agent header',
                    type: 'string',
                    default: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
                }
            ],
            testPaths: Object.values(this.vulnerabilityTypes).reduce((total, arr) => total + arr.length, 0),
            httpMethods: this.httpMethods.length,
            securityHeaders: this.securityHeaders.length,
            errorPatterns: this.errorPatterns.length
        };
    }
}

module.exports = WebVulnScannerExploit;
