const axios = require('axios');

const API_BASE = 'http://localhost:3003/api/security';

async function testMultiExploitFix() {
    console.log('ğŸ§ª Testing Multi-Exploit Results Fix');
    console.log('='.repeat(50));

    try {
        // Wait for server to be ready
        console.log('ğŸ”„ Checking server status...');
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Clear any existing results
        console.log('ğŸ—‘ï¸ Clearing previous results...');
        try {
            await axios.post(`${API_BASE}/clear-results`);
            console.log('âœ… Previous results cleared');
        } catch (e) {
            console.log('âš ï¸ Clear results failed (may not exist)');
        }

        // Run multi-exploit scan
        console.log('\nğŸ¯ Running multi-exploit scan...');
        const exploits = ['csrf', 'webVulnScanner', 'xss', 'sqlInjection', 'bufferOverflow'];

        const scanResponse = await axios.post(`${API_BASE}/scan-files`, {
            selectedExploits: exploits
        });

        if (!scanResponse.data.success) {
            throw new Error(`Scan failed: ${scanResponse.data.error}`);
        }

        console.log('âœ… Multi-exploit scan completed');
        console.log(`ğŸ“Š Scanned with ${scanResponse.data.data.results.length} exploits`);

        // Check results
        console.log('\nğŸ“‹ Checking scan results...');
        await new Promise(resolve => setTimeout(resolve, 1000));

        const resultsResponse = await axios.get(`${API_BASE}/results`);
        const results = resultsResponse.data.data.results;

        console.log(`ğŸ“ˆ Total result entries: ${results.length}`);

        // Analyze results by exploit type
        const exploitResults = {};
        results.forEach(result => {
            if (!exploitResults[result.exploitName]) {
                exploitResults[result.exploitName] = [];
            }
            exploitResults[result.exploitName].push(result);
        });

        console.log('\nğŸ” Results by exploit type:');
        exploits.forEach(exploit => {
            const count = exploitResults[exploit] ? exploitResults[exploit].length : 0;
            const vulnCount = exploitResults[exploit] ?
                exploitResults[exploit].reduce((sum, r) => sum + (r.vulnerabilities?.length || 0), 0) : 0;

            console.log(`   ${exploit}: ${count} result(s), ${vulnCount} vulnerabilities`);
        });

        // Check if all exploits have results
        const missingExploits = exploits.filter(exploit => !exploitResults[exploit]);
        const presentExploits = exploits.filter(exploit => exploitResults[exploit]);

        console.log('\nğŸ“Š Analysis:');
        console.log(`âœ… Exploits with results: ${presentExploits.length}/${exploits.length}`);

        if (missingExploits.length > 0) {
            console.log(`âŒ Missing exploit results: ${missingExploits.join(', ')}`);
            console.log('ğŸ’¡ This indicates the auto-clear fix may not be working');
        } else {
            console.log('ğŸ‰ All exploits preserved their results!');
            console.log('âœ… Auto-clear fix is working correctly');
        }

        // Show detailed vulnerability breakdown
        console.log('\nğŸ›¡ï¸ Vulnerability Summary:');
        Object.entries(exploitResults).forEach(([exploit, results]) => {
            results.forEach(result => {
                const vulnCount = result.vulnerabilities?.length || 0;
                const status = vulnCount > 0 ? 'ğŸ”´ FOUND' : 'ğŸŸ¢ CLEAN';
                console.log(`   ${exploit}: ${status} (${vulnCount} vulnerabilities)`);

                if (vulnCount > 0) {
                    result.vulnerabilities.slice(0, 2).forEach(vuln => {
                        console.log(`      - ${vuln.type} (${vuln.severity}) in ${vuln.location}`);
                    });
                }
            });
        });

        // Test single exploit scan (should still clear previous)
        console.log('\nğŸ”¬ Testing single exploit scan (should clear previous)...');
        const singleScanResponse = await axios.post(`${API_BASE}/scan-files`, {
            selectedExploits: ['networkScanner']
        });

        await new Promise(resolve => setTimeout(resolve, 1000));
        const afterSingleResults = await axios.get(`${API_BASE}/results`);
        const singleResults = afterSingleResults.data.data.results;

        console.log(`ğŸ“Š Results after single scan: ${singleResults.length}`);
        if (singleResults.length === 1 && singleResults[0].exploitName === 'networkScanner') {
            console.log('âœ… Single exploit scan correctly cleared previous results');
        } else {
            console.log('âš ï¸ Single exploit scan behavior may need verification');
        }

        console.log('\nğŸ¯ TEST SUMMARY:');
        console.log('='.repeat(30));

        if (presentExploits.length === exploits.length) {
            console.log('âœ… PASSED: Multi-exploit results are preserved');
            console.log('âœ… Fix is working correctly');
            console.log('ğŸ‰ Users should now see results from all exploits');
        } else {
            console.log('âŒ FAILED: Some exploit results are missing');
            console.log('ğŸ”§ Further debugging needed');
        }

    } catch (error) {
        console.error('\nâŒ Test failed:', error.message);
        if (error.response) {
            console.error('Response:', error.response.data);
        }
        console.log('\nğŸ”§ Troubleshooting:');
        console.log('1. Ensure server is running on port 3003');
        console.log('2. Check that files are uploaded for scanning');
        console.log('3. Verify API endpoints are accessible');
        process.exit(1);
    }
}

// Error handling
process.on('unhandledRejection', (reason) => {
    console.error('\nğŸ’¥ Unhandled promise rejection:', reason);
    process.exit(1);
});

// Run the test
console.log('Starting multi-exploit fix test...\n');
testMultiExploitFix().then(() => {
    console.log('\nğŸ Test completed!');
    process.exit(0);
});
